{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Cavatappi PHP Framework Documentation This is the documentation for the Cavatappi framework. For a general overview of the framework philosophy (the \"why\"), start with About the Framework . For a look at where things are going, see the Roadmap . For detailed info on how to use the framework, start with the Walkthrough . For a good time, call Strong Bad .","title":"Cavatappi PHP Framework Documentation"},{"location":"#cavatappi-php-framework-documentation","text":"This is the documentation for the Cavatappi framework. For a general overview of the framework philosophy (the \"why\"), start with About the Framework . For a look at where things are going, see the Roadmap . For detailed info on how to use the framework, start with the Walkthrough . For a good time, call Strong Bad .","title":"Cavatappi PHP Framework Documentation"},{"location":"about/","text":"About Cavatappi I'll assume you already know the benefits of using a framework, but if you don't, the TL;DR is less boilerplate code for you to write and maintain, which leaves you more time to focus on your app. So when I tell you that instead of using any of the existing frameworks I decided to build my own, you should have at least one question: Why? But Why? The short answer is because I wanted to. To elaborate, I was working on a big project with a small name and wanted to truly understand what my code was doing. I wanted to put the object-oriented lessons I was finally understanding into practice. I wanted something testable, portable, and lightweight. And I had just enough of a grasp of the modern PHP ecosystem to feel like I could do it, but not enough experience to tell me not to. This does beg another question: why should you use Cavatappi? Let me be a little blunt: you shouldn't. Don't use this Cavatappi, while born out of an existing project, does not currently have a production app to showcase it. It's ready for me to show the world, but it's not in a place where I'm comfortable using it for real production work. That being said, if the ideas on this site resonate with you and you want to help out, check out the GitHub repo and see what you can contribute. Why the name, though? I don't like cut-and-paste code. Lots of boilerplate tells me there's a chance for an abstraction, or at least a way to provide some sane defaults. So that's why the framework is named after a pasta: because I don't like copypasta. I chose this specific pasta because... The domain name was available, and It kinda looks like a snake. Thus, Cavatappi. Axioms Yes, it's reductive, but it helps get the ideas across. So here's some guiding principles for the Cavatappi framework: Defaults, not Dogma : Build features and abstractions so that simple apps can be written with minimal code, but deviations from the norm don't require re-implementing the entire feature. Try to maximize what can be done before a developer needs to abandon the framework's abstraction entirely. Signals, not Magic : Use explicit signals like PHP's type system and annotations to opt into behavior. Don't change the framework's behavior because a file is in a particular folder or a parameter has a particular name. The Basic Idea The basis for Cavatappi is that every class is either a Value or a Service : Value objects are (generally) immutable and used to store structured data. They should have no dependencies and be internally consistent. Value objects house state , not logic. Service objects are (generally) stateless and used to perform operations. They are given the dependencies they need at construction in order to work with structured data. Service objects house logic , not state. The Details Cavatappi takes this overall philosophy and uses it to help you build a well-organized app. Some other concepts make their way in, like: Registries : Find all classes that implement a particular interface and store information about them in a central location. This is currently the way to introduce extendability into applications. Commands and Events : Build a Domain Model that takes Command objects as input and dispatches Event objects with the result. Reflection : Use PHP's type system and annotations to build a meta-picture of classes that can be used to inform application behavior. Domain-driven Design : Isolate core application logic from general application concerns. Downstream Libraries Despite the foolishness of this endeavor, Cavatappi does build off several existing PHP libraries: Tukio and Serde by Larry Garfield ramsey/uuid by Ben Ramsey Construct Finder by The League of Extraordinary Packages nyholm/psr7 by Tobias Nyholm and Martijn van der Ven PHPUnit by Sebastian Bergmann","title":"About"},{"location":"about/#about-cavatappi","text":"I'll assume you already know the benefits of using a framework, but if you don't, the TL;DR is less boilerplate code for you to write and maintain, which leaves you more time to focus on your app. So when I tell you that instead of using any of the existing frameworks I decided to build my own, you should have at least one question:","title":"About Cavatappi"},{"location":"about/#why","text":"But Why? The short answer is because I wanted to. To elaborate, I was working on a big project with a small name and wanted to truly understand what my code was doing. I wanted to put the object-oriented lessons I was finally understanding into practice. I wanted something testable, portable, and lightweight. And I had just enough of a grasp of the modern PHP ecosystem to feel like I could do it, but not enough experience to tell me not to. This does beg another question: why should you use Cavatappi? Let me be a little blunt: you shouldn't.","title":"Why?"},{"location":"about/#dont-use-this","text":"Cavatappi, while born out of an existing project, does not currently have a production app to showcase it. It's ready for me to show the world, but it's not in a place where I'm comfortable using it for real production work. That being said, if the ideas on this site resonate with you and you want to help out, check out the GitHub repo and see what you can contribute.","title":"Don't use this"},{"location":"about/#why-the-name-though","text":"I don't like cut-and-paste code. Lots of boilerplate tells me there's a chance for an abstraction, or at least a way to provide some sane defaults. So that's why the framework is named after a pasta: because I don't like copypasta. I chose this specific pasta because... The domain name was available, and It kinda looks like a snake. Thus, Cavatappi.","title":"Why the name, though?"},{"location":"about/#axioms","text":"Yes, it's reductive, but it helps get the ideas across. So here's some guiding principles for the Cavatappi framework: Defaults, not Dogma : Build features and abstractions so that simple apps can be written with minimal code, but deviations from the norm don't require re-implementing the entire feature. Try to maximize what can be done before a developer needs to abandon the framework's abstraction entirely. Signals, not Magic : Use explicit signals like PHP's type system and annotations to opt into behavior. Don't change the framework's behavior because a file is in a particular folder or a parameter has a particular name.","title":"Axioms"},{"location":"about/#the-basic-idea","text":"The basis for Cavatappi is that every class is either a Value or a Service : Value objects are (generally) immutable and used to store structured data. They should have no dependencies and be internally consistent. Value objects house state , not logic. Service objects are (generally) stateless and used to perform operations. They are given the dependencies they need at construction in order to work with structured data. Service objects house logic , not state.","title":"The Basic Idea"},{"location":"about/#the-details","text":"Cavatappi takes this overall philosophy and uses it to help you build a well-organized app. Some other concepts make their way in, like: Registries : Find all classes that implement a particular interface and store information about them in a central location. This is currently the way to introduce extendability into applications. Commands and Events : Build a Domain Model that takes Command objects as input and dispatches Event objects with the result. Reflection : Use PHP's type system and annotations to build a meta-picture of classes that can be used to inform application behavior. Domain-driven Design : Isolate core application logic from general application concerns.","title":"The Details"},{"location":"about/#downstream-libraries","text":"Despite the foolishness of this endeavor, Cavatappi does build off several existing PHP libraries: Tukio and Serde by Larry Garfield ramsey/uuid by Ben Ramsey Construct Finder by The League of Extraordinary Packages nyholm/psr7 by Tobias Nyholm and Martijn van der Ven PHPUnit by Sebastian Bergmann","title":"Downstream Libraries"},{"location":"roadmap/","text":"Roadmap Everything is subject to change. Even this. Especially this. Current This is what's in the framework now Dependency Injection Using a stupidly simple container . Register Services automatically. Set up concrete implementations of interfaces and abstract classes. Registries Surfacing a class to the system is as simple as implements Interface . Register different adapters, add services to the dependency injection container, or other uses. Commands and Events Using a custom-built Command Bus and Tukio for event dispatching. Define a domain model with Commands as input and Events as output. Auto-register Command handlers and Event listeners. Sets up event sourcing for data persistence. Version 1 This is what I would consider the needed feature set before calling the framework ready for general use. API Set up a registry and configuration for an Endpoint class so that endpoints can be auto-registered. Use reflection tools to generate an OpenAPI (or similar) spec. Integrate with (or provide adapter to) something like Slim to handle routing. Markdown Registry system for Markdown customizations. Data Persistence Make it as easy to do event sourcing as most frameworks make CRUD . Registry for database tables. Integrate with Doctrine DBAL . Authentication Integrate with some library (what's the PHP equivalent to Omniauth ?) Create extendable User entity Some kind of OAuth or JWT scheme to secure APIs Make this effortless. Like, really effortless. Like works-out-of-the-box effortless. Further Enhancements The lofty ideas of things beyond version 1. UI Framework Build encapsulated UI components in PHP Use other design systems as a base and layer customizations on top Use reflection to make a form builder. Or just make a form builder. Seriously, can I have a form builder? Static Site Generation Have a way to generate HTML pages and save them to disk. Useful for making landing pages or outputting a single-page app Build System Generate hard-coded configurations and setups for Registries and other high-use classes. Optimize the system when it's in a stable place (staging/production) without compromising development speed. Allow other systems to hook in for generating documentation, web pages, etc. Smolblog That is why this whole thing started.","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"Everything is subject to change. Even this. Especially this.","title":"Roadmap"},{"location":"roadmap/#current","text":"This is what's in the framework now","title":"Current"},{"location":"roadmap/#dependency-injection","text":"Using a stupidly simple container . Register Services automatically. Set up concrete implementations of interfaces and abstract classes.","title":"Dependency Injection"},{"location":"roadmap/#registries","text":"Surfacing a class to the system is as simple as implements Interface . Register different adapters, add services to the dependency injection container, or other uses.","title":"Registries"},{"location":"roadmap/#commands-and-events","text":"Using a custom-built Command Bus and Tukio for event dispatching. Define a domain model with Commands as input and Events as output. Auto-register Command handlers and Event listeners. Sets up event sourcing for data persistence.","title":"Commands and Events"},{"location":"roadmap/#version-1","text":"This is what I would consider the needed feature set before calling the framework ready for general use.","title":"Version 1"},{"location":"roadmap/#api","text":"Set up a registry and configuration for an Endpoint class so that endpoints can be auto-registered. Use reflection tools to generate an OpenAPI (or similar) spec. Integrate with (or provide adapter to) something like Slim to handle routing.","title":"API"},{"location":"roadmap/#markdown","text":"Registry system for Markdown customizations.","title":"Markdown"},{"location":"roadmap/#data-persistence","text":"Make it as easy to do event sourcing as most frameworks make CRUD . Registry for database tables. Integrate with Doctrine DBAL .","title":"Data Persistence"},{"location":"roadmap/#authentication","text":"Integrate with some library (what's the PHP equivalent to Omniauth ?) Create extendable User entity Some kind of OAuth or JWT scheme to secure APIs Make this effortless. Like, really effortless. Like works-out-of-the-box effortless.","title":"Authentication"},{"location":"roadmap/#further-enhancements","text":"The lofty ideas of things beyond version 1.","title":"Further Enhancements"},{"location":"roadmap/#ui-framework","text":"Build encapsulated UI components in PHP Use other design systems as a base and layer customizations on top Use reflection to make a form builder. Or just make a form builder. Seriously, can I have a form builder?","title":"UI Framework"},{"location":"roadmap/#static-site-generation","text":"Have a way to generate HTML pages and save them to disk. Useful for making landing pages or outputting a single-page app","title":"Static Site Generation"},{"location":"roadmap/#build-system","text":"Generate hard-coded configurations and setups for Registries and other high-use classes. Optimize the system when it's in a stable place (staging/production) without compromising development speed. Allow other systems to hook in for generating documentation, web pages, etc.","title":"Build System"},{"location":"roadmap/#smolblog","text":"That is why this whole thing started.","title":"Smolblog"},{"location":"packages/","text":"Packages Foundation Everything you need to define and build a Domain Model. Infrastructure Application-level utilities and services. Testing Because you need to write tests. Yes, you. And you.","title":"Packages"},{"location":"packages/#packages","text":"Foundation Everything you need to define and build a Domain Model. Infrastructure Application-level utilities and services. Testing Because you need to write tests. Yes, you. And you.","title":"Packages"},{"location":"packages/foundation/","text":"Cavatappi Foundation Base-level interfaces and traits for defining a domain model. Installation composer require cavatappi/foundation","title":"Cavatappi Foundation"},{"location":"packages/foundation/#cavatappi-foundation","text":"Base-level interfaces and traits for defining a domain model.","title":"Cavatappi Foundation"},{"location":"packages/foundation/#installation","text":"composer require cavatappi/foundation","title":"Installation"},{"location":"packages/infrastructure/","text":"Cavatappi Foundation Application-level services. Installation composer require cavatappi/infrastructure","title":"Cavatappi Foundation"},{"location":"packages/infrastructure/#cavatappi-foundation","text":"Application-level services.","title":"Cavatappi Foundation"},{"location":"packages/infrastructure/#installation","text":"composer require cavatappi/infrastructure","title":"Installation"},{"location":"packages/testing/","text":"Cavatappi Test Utilities Make tests suck less. Because you need to write them. Yes, you. Installation composer require --dev cavatappi/testing","title":"Cavatappi Test Utilities"},{"location":"packages/testing/#cavatappi-test-utilities","text":"Make tests suck less. Because you need to write them. Yes, you.","title":"Cavatappi Test Utilities"},{"location":"packages/testing/#installation","text":"composer require --dev cavatappi/testing","title":"Installation"},{"location":"walkthrough/","text":"Cavatappi Walkthrough It's not a tutorial, mostly because this is me solving a personal problem and bringing you, the reader, along for the ride. This is happening in near-real-time, so there might be some hiccups along the way. For this, I'll be making a backend for a web version of my iOS app, PillTimer . It's a simple app that tracks medicine doses and calculates when your next dose is. It's the kind of simple but feature-complete app I hope that Cavatappi can excel at, so lets give it a shot! Setup Initialize Composer and install the packages. Values Learn about how Value objects work in Cavatappi. More chapters to come as the app and framework mature.","title":"Intro"},{"location":"walkthrough/#cavatappi-walkthrough","text":"It's not a tutorial, mostly because this is me solving a personal problem and bringing you, the reader, along for the ride. This is happening in near-real-time, so there might be some hiccups along the way. For this, I'll be making a backend for a web version of my iOS app, PillTimer . It's a simple app that tracks medicine doses and calculates when your next dose is. It's the kind of simple but feature-complete app I hope that Cavatappi can excel at, so lets give it a shot! Setup Initialize Composer and install the packages. Values Learn about how Value objects work in Cavatappi. More chapters to come as the app and framework mature.","title":"Cavatappi Walkthrough"},{"location":"walkthrough/01-setup/","text":"Setup This is mostly setting up Composer with the Cavatappi packages and some extra tricks I like to have. Step 1: composer init Yeah, I'm basic. I've already got Composer installed via Homebrew , so I'll run its built-in step-by-step initializer: brew install composer composer init I'm only going to use the Foundation package for now while things get set up. And while Cavatappi itself uses the ASF license , I'm going to restrict this project's code to the GNU Affero GPL license . (That being said, all code samples in the documentation are public domain via CC0 , so reuse and modify anything you see here for whatever purpose you want!) At the end, I'll have a composer.json file that looks something like this: { \"name\": \"oddevan/pilltimer\", \"description\": \"Backend for the web version of PillTimer\", \"type\": \"project\", \"require\": { \"cavatappi/foundation\": \"^0.1.0\" }, \"license\": \"AGPL-3.0\", \"autoload\": { \"psr-4\": { \"oddEvan\\\\PillTimer\\\\\": \"src/\" } }, \"authors\": [ { \"name\": \"Evan Hildreth\", \"email\": \"me@eph.me\" } ] } Normally in a Composer project we would need to include the autoloader, but we're not there yet. And we won't be for some time. Step 2: Standards and Practices I like having some reasonable coding standards in place, if only because it means I can auto-format my code. Because this is a personal project and not necessarily intended for other developers to build off of, I'm mostly going to limit the included standards to code formatting and forgo the more documentation-heavy ones. I use [PHP_CodeSniffer] mostly because that's what dominates the WordPress ecosystem and therefore what I learned first. composer require --dev squizlabs/php_codesniffer And then add a .phpcs.xml config file that looks like this (suspiciously similar to Cavatappi's): <?xml version=\"1.0\"?> <ruleset name=\"PillTimer Standards\" namespace=\"oddEvan\\PillTimer\"> <description>Coding standards for PillTimer.</description> <file>./src</file> <exclude-pattern>*/src-test/*</exclude-pattern> <exclude-pattern>*/tests/*</exclude-pattern> <arg name=\"extensions\" value=\"php\"/> <arg name=\"tab-width\" value=\"2\"/> <arg name=\"colors\"/> <arg value=\"s\"/> <ini name=\"memory_limit\" value=\"64M\"/> <autoload>./vendor/autoload.php</autoload> <!-- Use PSR-12 as our base --> <rule ref=\"PSR12\"> <exclude name=\"Generic.WhiteSpace.DisallowTabIndent\"/> <exclude name=\"Generic.WhiteSpace.ScopeIndent\"/> <exclude name=\"PSR2.Classes.ClassDeclaration.OpenBraceNewLine\"/> <exclude name=\"PSR2.Methods.FunctionCallSignature.Indent\"/> <exclude name=\"Squiz.Functions.MultiLineFunctionDeclaration.BraceOnSameLine\"/> <exclude name=\"Squiz.Functions.MultiLineFunctionDeclaration.Indent\"/> </rule> <rule ref=\"PSR2.Methods.FunctionCallSignature.Indent\"> <properties> <property name=\"indent\" value=\"2\"/> </properties> </rule> <!-- Use tabs, please. Please. Seriously. --> <!-- https://alexandersandberg.com/articles/default-to-tabs-instead-of-spaces-for-an-accessible-first-environment/ --> <rule ref=\"Generic.WhiteSpace.DisallowSpaceIndent\"/> <rule ref=\"Generic.WhiteSpace.ScopeIndent\"> <properties> <property name=\"indent\" value=\"2\"/> <property name=\"tabIndent\" value=\"true\"/> <property name=\"ignoreIndentationTokens\" type=\"array\"> <element value=\"T_COMMENT\"/> <element value=\"T_DOC_COMMENT_OPEN_TAG\"/> </property> </properties> </rule> <!-- Make structures look nicer --> <rule ref=\"Generic.Classes.OpeningBraceSameLine\"/> <rule ref=\"Generic.Functions.OpeningFunctionBraceKernighanRitchie\"/> </ruleset> That's enough to tie into my code editor, but I like having some command line shortcuts, especially when it comes to auto-formatting. I'll add this to my composer.json file: \"scripts\": { \"lint\": \"./vendor/squizlabs/php_codesniffer/bin/phpcs\", \"lintfix\": \"./vendor/squizlabs/php_codesniffer/bin/phpcbf\" } OK, enough messing around. On to the next step: defining our data model !","title":"Setup"},{"location":"walkthrough/01-setup/#setup","text":"This is mostly setting up Composer with the Cavatappi packages and some extra tricks I like to have.","title":"Setup"},{"location":"walkthrough/01-setup/#step-1-composer-init","text":"Yeah, I'm basic. I've already got Composer installed via Homebrew , so I'll run its built-in step-by-step initializer: brew install composer composer init I'm only going to use the Foundation package for now while things get set up. And while Cavatappi itself uses the ASF license , I'm going to restrict this project's code to the GNU Affero GPL license . (That being said, all code samples in the documentation are public domain via CC0 , so reuse and modify anything you see here for whatever purpose you want!) At the end, I'll have a composer.json file that looks something like this: { \"name\": \"oddevan/pilltimer\", \"description\": \"Backend for the web version of PillTimer\", \"type\": \"project\", \"require\": { \"cavatappi/foundation\": \"^0.1.0\" }, \"license\": \"AGPL-3.0\", \"autoload\": { \"psr-4\": { \"oddEvan\\\\PillTimer\\\\\": \"src/\" } }, \"authors\": [ { \"name\": \"Evan Hildreth\", \"email\": \"me@eph.me\" } ] } Normally in a Composer project we would need to include the autoloader, but we're not there yet. And we won't be for some time.","title":"Step 1: composer init"},{"location":"walkthrough/01-setup/#step-2-standards-and-practices","text":"I like having some reasonable coding standards in place, if only because it means I can auto-format my code. Because this is a personal project and not necessarily intended for other developers to build off of, I'm mostly going to limit the included standards to code formatting and forgo the more documentation-heavy ones. I use [PHP_CodeSniffer] mostly because that's what dominates the WordPress ecosystem and therefore what I learned first. composer require --dev squizlabs/php_codesniffer And then add a .phpcs.xml config file that looks like this (suspiciously similar to Cavatappi's): <?xml version=\"1.0\"?> <ruleset name=\"PillTimer Standards\" namespace=\"oddEvan\\PillTimer\"> <description>Coding standards for PillTimer.</description> <file>./src</file> <exclude-pattern>*/src-test/*</exclude-pattern> <exclude-pattern>*/tests/*</exclude-pattern> <arg name=\"extensions\" value=\"php\"/> <arg name=\"tab-width\" value=\"2\"/> <arg name=\"colors\"/> <arg value=\"s\"/> <ini name=\"memory_limit\" value=\"64M\"/> <autoload>./vendor/autoload.php</autoload> <!-- Use PSR-12 as our base --> <rule ref=\"PSR12\"> <exclude name=\"Generic.WhiteSpace.DisallowTabIndent\"/> <exclude name=\"Generic.WhiteSpace.ScopeIndent\"/> <exclude name=\"PSR2.Classes.ClassDeclaration.OpenBraceNewLine\"/> <exclude name=\"PSR2.Methods.FunctionCallSignature.Indent\"/> <exclude name=\"Squiz.Functions.MultiLineFunctionDeclaration.BraceOnSameLine\"/> <exclude name=\"Squiz.Functions.MultiLineFunctionDeclaration.Indent\"/> </rule> <rule ref=\"PSR2.Methods.FunctionCallSignature.Indent\"> <properties> <property name=\"indent\" value=\"2\"/> </properties> </rule> <!-- Use tabs, please. Please. Seriously. --> <!-- https://alexandersandberg.com/articles/default-to-tabs-instead-of-spaces-for-an-accessible-first-environment/ --> <rule ref=\"Generic.WhiteSpace.DisallowSpaceIndent\"/> <rule ref=\"Generic.WhiteSpace.ScopeIndent\"> <properties> <property name=\"indent\" value=\"2\"/> <property name=\"tabIndent\" value=\"true\"/> <property name=\"ignoreIndentationTokens\" type=\"array\"> <element value=\"T_COMMENT\"/> <element value=\"T_DOC_COMMENT_OPEN_TAG\"/> </property> </properties> </rule> <!-- Make structures look nicer --> <rule ref=\"Generic.Classes.OpeningBraceSameLine\"/> <rule ref=\"Generic.Functions.OpeningFunctionBraceKernighanRitchie\"/> </ruleset> That's enough to tie into my code editor, but I like having some command line shortcuts, especially when it comes to auto-formatting. I'll add this to my composer.json file: \"scripts\": { \"lint\": \"./vendor/squizlabs/php_codesniffer/bin/phpcs\", \"lintfix\": \"./vendor/squizlabs/php_codesniffer/bin/phpcbf\" } OK, enough messing around. On to the next step: defining our data model !","title":"Step 2: Standards and Practices"},{"location":"walkthrough/02-values/","text":"Values Let's set up some initial Value objects to represent the data we need. Step 0: Figure out what we need A little bit of planning goes a long way. So let me think out loud about what this app will do. I find it easiest to start with actions: what the app will need to do. In this case: User creates a medicine with dosage information. User updates a medicine with new information. User records a dose, and the app updates the next dose. User removes a dose that was incorrectly entered. User archives a medicine they are no longer taking. User removes a medicine they no longer need data for. User un-archives a medicine they are taking again. That's enough for us to define our domain model , the core of the application logic. And we can already see some nouns and verbs that will guide us to our definitions: Entities (things that are stored and acted on) User Medicine Dose Commands (actions that are taken) Create Medicine Update Medicine Archive Medicine Restore Medicine (un-archive) Record Dose Delete Dose Events (results of actions) Medicine Created Medicine Updated Medicine Archived Medicine Restored Dose Added Dose Deleted That looks good to me! Step 1: Entities An Entity in Cavatappi is an object with an id , specifically a UUID from ramsey/uuid . It can be randomly generated or deterministically generated, but it has an ID. Our User entity is going to look pretty bare for now, as we only need the ID: use Cavatappi\\Foundation\\DomainEvent\\Entity; use Cavatappi\\Foundation\\Value; use Cavatappi\\Foundation\\Value\\ValueKit; use Ramsey\\Uuid\\UuidInterface; readonly class User implements Value, Entity { use ValueKit; public function __construct(public UuidInterface $id) {} } But this gives us a chance to talk about Value . In Cavatappi, every class is either a Value or a Service. Values store information, and Services encapsulate logic. It's how I stick to the single-responsibility principle . Value objects should be read-only, but this isn't enforced at the code level. (I tried; it breaks down too easily.) That's why instead of a superclass, we have an interface and a trait defining three methods: with - Creates a clone of the object with the given property changes. equals - Tests the object for equality with the given object, accounting for inconsistencies in properties. (For example: if a property is Stringable , it compares the string values instead of the objects themselves.) static reflect - Pulls information from annotations and PHP's type system into a standard format that can be modified. Most Value classes will only need to use ValueKit to get all this for free. Our Medicine entity will have a little more data: readonly class Medicine implements Value, Entity, Validated { use ValueKit; public UuidInterface $id; public function __construct( public string $name, public UuidInterface $userId, ?UuidInterface $id = null, public ?int $hourlyInterval = null, public ?int $dailyLimit = null, public bool $alert = false, public bool $archived = false, public ?DateTimeInterface $nextDose = null, ) { $this->id = $id ?? UuidFactory::random(); $this->validate(); } public function validate(): void { if (isset($this->hourlyInterval) && $this->hourlyInterval <= 0) { throw new InvalidValueProperties('Hourly interval must be null or positive.', field: 'hourlyInterval'); } if (isset($this->dailyLimit) && $this->dailyLimit <= 0) { throw new InvalidValueProperties('Hourly interval must be null or positive.', field: 'dailyLimit'); } } } Here we're storing a name, the two pieces of timing information, and a couple of flags for application functions. We're also introducing the Validated interface. Since some scenarios (like serialization or cloning) bypass the constructor, this breaks validation out into a separate function, validate , that can be called outside of the constructor. We should still call it within the constructor! We're also adding a default ID. If one isn't provided (a.k.a. this is a new Medicine), the constructor will create one using UuidFactory , a static class for working with UUIDs inside a Value object. We'll round it out with Dose which is almost as simple as User: readonly class Dose implements Value, Entity { use ValueKit; public function __construct( public UuidInterface $id, public UuidInterface $medicineId, public DateTimeInterface $timestamp, ) { } } Step 2: Commands + Events Command and Event objects represent input and output to the domain model. Just like a function has parameters and a return value, a domain model takes command objects and dispatches events with the results. It helps disconnect our core logic from how our application is built: whether we use a PHP-based frontend or an API, our domain model will get the same input. (Plus, it helps define how to test the app, which we are going to do.) For the sake of brevity, we'll just look at a couple of command/event pairs. First, adding a Medicine: use Cavatappi\\Foundation\\Command\\Authenticated; use Cavatappi\\Foundation\\Command\\Command; use Cavatappi\\Foundation\\Value\\ValueKit; use oddEvan\\PillTimer\\Entities\\Medicine; use Ramsey\\Uuid\\UuidInterface; class AddMedicine implements Command, Authenticated { use ValueKit; public function __construct( public readonly Medicine $medicine, public readonly UuidInterface $userId, ) { } } The class itself is pretty sparse. But doing this allows us to use the validation code we already put in the Medicine entity class. The AddMedicine command basically says \"add this Medicine.\" The Authenticated interface requires a userId UUID property. It is assumed that the value of that property is a user that has been authenticated : that is, their identity has been verified and they are who they say they are, at least as far as our app is concerned. This authenticated user is the one performing the action, and it's whose authorization we'll check later. So why not just use $medicine->userId ? Good question! In this particular case, I'm making it a separate property to account for potential cases where a user is adding a Medicine for someone else. Maybe it's an import process, or an administrator making a change. Maybe there's a use-case later on for a family plan? Either way, it feels safer to have it be a separate property for now. The corresponding Event looks similar: use Cavatappi\\Foundation\\DomainEvent\\DomainEvent; use Cavatappi\\Foundation\\Factories\\UuidFactory; use DateTimeImmutable; use DateTimeInterface; use oddEvan\\PillTimer\\Entities\\Medicine; use Ramsey\\Uuid\\UuidInterface; class MedicineAdded implements DomainEvent { use ValueKit; public readonly UuidInterface $id; public readonly DateTimeInterface $timestamp; public function __construct( public readonly Medicine $medicine, public readonly UuidInterface $userId, ?UuidInterface $id = null, ?DateTimeInterface $timestamp = null, public readonly ?UuidInterface $processId = null, ) { $this->timestamp = $timestamp ?? new DateTimeImmutable(); $this->id = $id ?? UuidFactory::date($this->timestamp); } public string $type { get => self::class; } public UuidInterface $entityId { get => $this->medicine->id; } public UuidInterface $aggregateId { get => $this->medicine->id; } } This has some added data, mostly to satisfy the DomainEvent interface. There's a lot here, mostly to facilitate indexing a stream of events: entityId is the ID for the entity being affected by this event, in this case the Medicine. aggregateId is the ID for a broader entity or group that this entity is part of. In this case, it's still the Medicine. processId is a way to denote events that are linked by a process, such as an import or remote system call. We're also using the UuidFactory::date function to create a version 7 UUID since events are created and stored in sequential order. To provide a little more context, here's a Command and Event for adding a Dose: readonly class AddDose implements Command, Authenticated { use ValueKit; public function __construct( public Dose $dose, public UuidInterface $userId, ) { } } class DoseAdded implements DomainEvent { use ValueKit; public readonly UuidInterface $id; public readonly DateTimeInterface $timestamp; public function __construct( public readonly Dose $dose, public readonly UuidInterface $userId, ?UuidInterface $id = null, ?DateTimeInterface $timestamp = null, public readonly ?UuidInterface $processId = null, ) { $this->timestamp = $timestamp ?? new DateTimeImmutable(); $this->id = $id ?? UuidFactory::date($this->timestamp); } public string $type { get => self::class; } public UuidInterface $entityId { get => $this->dose->id; } public UuidInterface $aggregateId { get => $this->dose->medicineId; } } They're very simliar to the Medicine command and event. The most notable difference is while the entityId is the Dose ID, the aggregateId is still the Medicine ID since that's the \"group\" the Dose belongs to. Wrapup So wait, if the command and event are so similar, why not just combine them? Especially if the command is already authenticated? A big part of it is intent. A Command represents something that should happen, while an Event is something that has happened. In between the two is the domain model code, including authorization. While we know who is making the request, it is up to the domain model to determine if they can. Not every Command will result in an Event. As for how similar these Commands and Events are and how they look like copypasta, the very thing this framework wants to avoid? Well, that's being worked on. Hopefully, as we get closer to version 1, this walkthrough will look a little different.","title":"Values"},{"location":"walkthrough/02-values/#values","text":"Let's set up some initial Value objects to represent the data we need.","title":"Values"},{"location":"walkthrough/02-values/#step-0-figure-out-what-we-need","text":"A little bit of planning goes a long way. So let me think out loud about what this app will do. I find it easiest to start with actions: what the app will need to do. In this case: User creates a medicine with dosage information. User updates a medicine with new information. User records a dose, and the app updates the next dose. User removes a dose that was incorrectly entered. User archives a medicine they are no longer taking. User removes a medicine they no longer need data for. User un-archives a medicine they are taking again. That's enough for us to define our domain model , the core of the application logic. And we can already see some nouns and verbs that will guide us to our definitions: Entities (things that are stored and acted on) User Medicine Dose Commands (actions that are taken) Create Medicine Update Medicine Archive Medicine Restore Medicine (un-archive) Record Dose Delete Dose Events (results of actions) Medicine Created Medicine Updated Medicine Archived Medicine Restored Dose Added Dose Deleted That looks good to me!","title":"Step 0: Figure out what we need"},{"location":"walkthrough/02-values/#step-1-entities","text":"An Entity in Cavatappi is an object with an id , specifically a UUID from ramsey/uuid . It can be randomly generated or deterministically generated, but it has an ID. Our User entity is going to look pretty bare for now, as we only need the ID: use Cavatappi\\Foundation\\DomainEvent\\Entity; use Cavatappi\\Foundation\\Value; use Cavatappi\\Foundation\\Value\\ValueKit; use Ramsey\\Uuid\\UuidInterface; readonly class User implements Value, Entity { use ValueKit; public function __construct(public UuidInterface $id) {} } But this gives us a chance to talk about Value . In Cavatappi, every class is either a Value or a Service. Values store information, and Services encapsulate logic. It's how I stick to the single-responsibility principle . Value objects should be read-only, but this isn't enforced at the code level. (I tried; it breaks down too easily.) That's why instead of a superclass, we have an interface and a trait defining three methods: with - Creates a clone of the object with the given property changes. equals - Tests the object for equality with the given object, accounting for inconsistencies in properties. (For example: if a property is Stringable , it compares the string values instead of the objects themselves.) static reflect - Pulls information from annotations and PHP's type system into a standard format that can be modified. Most Value classes will only need to use ValueKit to get all this for free. Our Medicine entity will have a little more data: readonly class Medicine implements Value, Entity, Validated { use ValueKit; public UuidInterface $id; public function __construct( public string $name, public UuidInterface $userId, ?UuidInterface $id = null, public ?int $hourlyInterval = null, public ?int $dailyLimit = null, public bool $alert = false, public bool $archived = false, public ?DateTimeInterface $nextDose = null, ) { $this->id = $id ?? UuidFactory::random(); $this->validate(); } public function validate(): void { if (isset($this->hourlyInterval) && $this->hourlyInterval <= 0) { throw new InvalidValueProperties('Hourly interval must be null or positive.', field: 'hourlyInterval'); } if (isset($this->dailyLimit) && $this->dailyLimit <= 0) { throw new InvalidValueProperties('Hourly interval must be null or positive.', field: 'dailyLimit'); } } } Here we're storing a name, the two pieces of timing information, and a couple of flags for application functions. We're also introducing the Validated interface. Since some scenarios (like serialization or cloning) bypass the constructor, this breaks validation out into a separate function, validate , that can be called outside of the constructor. We should still call it within the constructor! We're also adding a default ID. If one isn't provided (a.k.a. this is a new Medicine), the constructor will create one using UuidFactory , a static class for working with UUIDs inside a Value object. We'll round it out with Dose which is almost as simple as User: readonly class Dose implements Value, Entity { use ValueKit; public function __construct( public UuidInterface $id, public UuidInterface $medicineId, public DateTimeInterface $timestamp, ) { } }","title":"Step 1: Entities"},{"location":"walkthrough/02-values/#step-2-commands-events","text":"Command and Event objects represent input and output to the domain model. Just like a function has parameters and a return value, a domain model takes command objects and dispatches events with the results. It helps disconnect our core logic from how our application is built: whether we use a PHP-based frontend or an API, our domain model will get the same input. (Plus, it helps define how to test the app, which we are going to do.) For the sake of brevity, we'll just look at a couple of command/event pairs. First, adding a Medicine: use Cavatappi\\Foundation\\Command\\Authenticated; use Cavatappi\\Foundation\\Command\\Command; use Cavatappi\\Foundation\\Value\\ValueKit; use oddEvan\\PillTimer\\Entities\\Medicine; use Ramsey\\Uuid\\UuidInterface; class AddMedicine implements Command, Authenticated { use ValueKit; public function __construct( public readonly Medicine $medicine, public readonly UuidInterface $userId, ) { } } The class itself is pretty sparse. But doing this allows us to use the validation code we already put in the Medicine entity class. The AddMedicine command basically says \"add this Medicine.\" The Authenticated interface requires a userId UUID property. It is assumed that the value of that property is a user that has been authenticated : that is, their identity has been verified and they are who they say they are, at least as far as our app is concerned. This authenticated user is the one performing the action, and it's whose authorization we'll check later. So why not just use $medicine->userId ? Good question! In this particular case, I'm making it a separate property to account for potential cases where a user is adding a Medicine for someone else. Maybe it's an import process, or an administrator making a change. Maybe there's a use-case later on for a family plan? Either way, it feels safer to have it be a separate property for now. The corresponding Event looks similar: use Cavatappi\\Foundation\\DomainEvent\\DomainEvent; use Cavatappi\\Foundation\\Factories\\UuidFactory; use DateTimeImmutable; use DateTimeInterface; use oddEvan\\PillTimer\\Entities\\Medicine; use Ramsey\\Uuid\\UuidInterface; class MedicineAdded implements DomainEvent { use ValueKit; public readonly UuidInterface $id; public readonly DateTimeInterface $timestamp; public function __construct( public readonly Medicine $medicine, public readonly UuidInterface $userId, ?UuidInterface $id = null, ?DateTimeInterface $timestamp = null, public readonly ?UuidInterface $processId = null, ) { $this->timestamp = $timestamp ?? new DateTimeImmutable(); $this->id = $id ?? UuidFactory::date($this->timestamp); } public string $type { get => self::class; } public UuidInterface $entityId { get => $this->medicine->id; } public UuidInterface $aggregateId { get => $this->medicine->id; } } This has some added data, mostly to satisfy the DomainEvent interface. There's a lot here, mostly to facilitate indexing a stream of events: entityId is the ID for the entity being affected by this event, in this case the Medicine. aggregateId is the ID for a broader entity or group that this entity is part of. In this case, it's still the Medicine. processId is a way to denote events that are linked by a process, such as an import or remote system call. We're also using the UuidFactory::date function to create a version 7 UUID since events are created and stored in sequential order. To provide a little more context, here's a Command and Event for adding a Dose: readonly class AddDose implements Command, Authenticated { use ValueKit; public function __construct( public Dose $dose, public UuidInterface $userId, ) { } } class DoseAdded implements DomainEvent { use ValueKit; public readonly UuidInterface $id; public readonly DateTimeInterface $timestamp; public function __construct( public readonly Dose $dose, public readonly UuidInterface $userId, ?UuidInterface $id = null, ?DateTimeInterface $timestamp = null, public readonly ?UuidInterface $processId = null, ) { $this->timestamp = $timestamp ?? new DateTimeImmutable(); $this->id = $id ?? UuidFactory::date($this->timestamp); } public string $type { get => self::class; } public UuidInterface $entityId { get => $this->dose->id; } public UuidInterface $aggregateId { get => $this->dose->medicineId; } } They're very simliar to the Medicine command and event. The most notable difference is while the entityId is the Dose ID, the aggregateId is still the Medicine ID since that's the \"group\" the Dose belongs to.","title":"Step 2: Commands + Events"},{"location":"walkthrough/02-values/#wrapup","text":"So wait, if the command and event are so similar, why not just combine them? Especially if the command is already authenticated? A big part of it is intent. A Command represents something that should happen, while an Event is something that has happened. In between the two is the domain model code, including authorization. While we know who is making the request, it is up to the domain model to determine if they can. Not every Command will result in an Event. As for how similar these Commands and Events are and how they look like copypasta, the very thing this framework wants to avoid? Well, that's being worked on. Hopefully, as we get closer to version 1, this walkthrough will look a little different.","title":"Wrapup"},{"location":"walkthrough/03-services/","text":"Services We've got lots of data, now let's do something with it! Step 0: Figure out what we need Sorry, but that's always step zero. In this case, let's go back to our list of actions: User creates a medicine with dosage information. User updates a medicine with new information. User records a dose, and the app updates the next dose. User removes a dose that was incorrectly entered. User archives a medicine they are no longer taking. User removes a medicine they no longer need data for. User un-archives a medicine they are taking again. I'm seeing a few potential Service objects here. Let's lay them out: Medicine Management (create/update/delete/archive) Medicine Repository (data storage) Dose Management (create/delete) Dose Repository (data storage) Next Dose Calculation Now, are 1-4 strictly single-responsibility? No. But making a separate service for every create, update, and delete operation feels exceedingly tedious. We can map Command objects to individual methods in the service, so one service can handle multiple commands. The repositories are separate so that we can separate our domain logic from our data storage. In our domain model, each one will just be an interface . We'll get to the actual database storage... later. Finally, our service for next dose calculation is its own thing for a couple of reasons. One, it's a significantly different pattern from the others. Two, instead of handling commands, it's going to react to Event objects. Whenever an event happens that could change when the next dose of medicine is, this service will recalculate the next dose and send its own event to mark the change. Step 1: Repo Interfaces Since the other services will depend on the repository interfaces, we'll define them first: use oddEvan\\PillTimer\\Entities\\Medicine; use Ramsey\\Uuid\\UuidInterface; interface MedicineRepo { public function has(UuidInterface $medicineId): bool; public function get(UuidInterface $medicineId): ?Medicine; public function setNextDose(UuidInterface $medicineId, DateTimeInterface $timestamp): void; } I like to use has and get to mirror PSR-11 , but that's a personal choice. There's also a setNextDose method for reasons we'll get into in a bit. Dose needs a slightly different method: interface DoseRepo { /** @return Dose[] */ public function dosesForMedicineInLastDay(UuidInterface $medicineId): array; } Calculating the next dose is only going to need doses from the last 24 hours, so that's what this method is limited to. Now that we have these interfaces, we can type-hint against them in our services. Step 2: Management Services These are all pretty similar (and something I'm hoping to provide some shortcuts for in the future), so here's the idea: use Cavatappi\\Foundation\\Command\\{CommandHandler, CommandHandlerService}; use Cavatappi\\Foundation\\Exceptions\\{ActionNotAuthorized, InvalidValueProperties}; use Cavatappi\\Foundation\\Factories\\UuidFactory; use oddEvan\\PillTimer\\Commands\\AddMedicine; use oddEvan\\PillTimer\\Events\\MedicineAdded; use Psr\\EventDispatcher\\EventDispatcherInterface; class MedicineService implements CommandHandlerService { public function __construct( private MedicineRepo $repo, private EventDispatcherInterface $eventBus ) { } #[CommandHandler] public function addMedicine(AddMedicine $cmd): void { if ($this->repo->has($cmd->medicine->id)) { throw new InvalidValueProperties(\"A medicine with the ID {$cmd->medicine->id} already exists\"); } if (!$cmd->userId->equals($cmd->medicine->userId)) { throw new ActionNotAuthorized('You cannot create a Medicine for someone else.'); } $this->eventBus->dispatch(new MedicineAdded( medicine: $cmd->medicine, userId: $cmd->userId, )); } } First off, we declare dependencies in the constructor: the MedicineRepo we defined earlier along with an EventDispatcherInterface from PSR-14 , which we use to dispatch the event. As an example of a CommandHandler , we have one for the AddMedicine command. Remember, the only preconditions for a command object are It is a valid object according to its conditions, and If it is an Authenticated command, the userId property represents the user issuing the command. Everything else is domain-specific. So for PillTimer, we check: Is the ID already in use? This is a create method, so there shouldn't already be a Mediicne with this ID. Is the user authorized? For now, we're only checking if the user is creating a medicine for themselves. In the future we may call out to a separate service for more fine-grained permissions. If all the conditions are met, we should save the Medicine. To do that, we dispatch the MedicineAdded event and add the appropriate information. With that, the domain model's work is done, right? Eh, not quite. Step 3: Ephemeral Data The idea behind an event-sourced system is to store the events with their necessary data; everything else is ephemeral. For PillTimer, that includes the time of the next dose. It's not something explicitly entered by the user, it's calculated using: The doses in the last 24 hours, The time allowed between doses, and The number of allowed doses per 24 hours. That's why, instead of having a \"Next Dose Time Set\" event, we have a method on the MedicineRepo to add the information to the Medicine object. Other methods could include keeping the information in a separate repository or calculating it on-the-fly every time it's needed. This method feels the most straightforward to me, at least right now. So how do we calculate this when we need to? We listen for any events that might change the next dose time and run our code then. There are two ways we could do this: List all the events to listen for in our service, or Declare an interface for all appropriate events to implement. I personally think that either method is valid, especially on a small app like this for an event intended to be used by its own domain model. The second feels like less typing, so I'm going to go with that one. First, we declare a new interface: interface ChangesNextDoseTime { public function doseTime(): ?DateTimeInterface; } We could have made it completely empty, but this will make the code simpler in our service without compromising the Events themselves. Next, we add the new interface to our existing events and implement the new method. For DoseAdded , it's simple: class DoseAdded implements DomainEvent, ChangesNextDoseTime { // ... public function doseTime(): ?DateTimeInterface { return $this->dose->timestamp; } } We would do the same for a DoseDeleted event (which is good to know since normally we wouldn't include info from the entity on an event deleting it). For MedicineAdded , though, we forgo the interface entirely. A new medicine won't have any doses, so it won't have a time for a next dose. MedicineUpdated , though, will, since it could change the timing: class MedicineUpdated implements DomainEvent, ChangesNextDoseTime { // ... public function doseTime(): ?DateTimeInterface { return null; } } Since there's no new dosage information, we return null . Once we've gotten all our events updated, we can create the new service: use Cavatappi\\Foundation\\DomainEvent\\EventListenerService; use Cavatappi\\Foundation\\DomainEvent\\ProjectionListener; use DateTimeImmutable; use oddEvan\\PillTimer\\Events\\ChangesNextDoseTime; class NextDoseService implements EventListenerService { public function __construct( private MedicineRepo $medicineRepo, private DoseRepo $doseRepo ) { } public const TWENTY_FOUR_HOURS = 24 * 60 * 60; #[ProjectionListener] public function recalculate(ChangesNextDoseTime $event) { $doseTime = $event->doseTime()?->getTimestamp() ?? null; if (isset($doseTime) && time() - $doseTime > self::TWENTY_FOUR_HOURS) { // A dose older than the last 24 hours was changed; we can safely ignore it. return; } $medicine = $this->medicineRepo->get($event->aggregateId); $doses = $this->doseRepo->dosesForMedicineInLastDay($event->aggregateId); usort($doses, fn($doseA, $doseB) => $doseA->timestamp->getTimestamp() - $doseB->timestamp->getTimestamp()); if (empty($doses)) { // No existing doses; we can safely ignore the event. return; } $this->medicineRepo->setNextDose( medicineId: $event->aggregateId, timestamp: self::calculate($doses, $medicine->hourlyInterval, $medicine->dailyLimit), ); } private static function calculate(array $doses, ?int $interval, ?int $limit): DateTimeImmutable { // idk; stuff? return new DateTimeImmutable(); } } (Yes, that's a placeholder.) There are two types of event listener attributes: EventListener and ProjectionListener . Both will be called when the given type-hinted event is dispatched. To save the whole event-sourcing conversation for later, we'll just say that a Projection-style listener shouldn't have side effects like calling other services, issuing commands, or the like. Since this is only calculating derived data, it's a Projection. Wrapup So that's a look at how Service classes work in Cavatappi. We're looking at incoming Commands, outgoing Events, and even consuming some of those downstream events. And all this means our system is now ready to test! Aren't you excited?","title":"Services"},{"location":"walkthrough/03-services/#services","text":"We've got lots of data, now let's do something with it!","title":"Services"},{"location":"walkthrough/03-services/#step-0-figure-out-what-we-need","text":"Sorry, but that's always step zero. In this case, let's go back to our list of actions: User creates a medicine with dosage information. User updates a medicine with new information. User records a dose, and the app updates the next dose. User removes a dose that was incorrectly entered. User archives a medicine they are no longer taking. User removes a medicine they no longer need data for. User un-archives a medicine they are taking again. I'm seeing a few potential Service objects here. Let's lay them out: Medicine Management (create/update/delete/archive) Medicine Repository (data storage) Dose Management (create/delete) Dose Repository (data storage) Next Dose Calculation Now, are 1-4 strictly single-responsibility? No. But making a separate service for every create, update, and delete operation feels exceedingly tedious. We can map Command objects to individual methods in the service, so one service can handle multiple commands. The repositories are separate so that we can separate our domain logic from our data storage. In our domain model, each one will just be an interface . We'll get to the actual database storage... later. Finally, our service for next dose calculation is its own thing for a couple of reasons. One, it's a significantly different pattern from the others. Two, instead of handling commands, it's going to react to Event objects. Whenever an event happens that could change when the next dose of medicine is, this service will recalculate the next dose and send its own event to mark the change.","title":"Step 0: Figure out what we need"},{"location":"walkthrough/03-services/#step-1-repo-interfaces","text":"Since the other services will depend on the repository interfaces, we'll define them first: use oddEvan\\PillTimer\\Entities\\Medicine; use Ramsey\\Uuid\\UuidInterface; interface MedicineRepo { public function has(UuidInterface $medicineId): bool; public function get(UuidInterface $medicineId): ?Medicine; public function setNextDose(UuidInterface $medicineId, DateTimeInterface $timestamp): void; } I like to use has and get to mirror PSR-11 , but that's a personal choice. There's also a setNextDose method for reasons we'll get into in a bit. Dose needs a slightly different method: interface DoseRepo { /** @return Dose[] */ public function dosesForMedicineInLastDay(UuidInterface $medicineId): array; } Calculating the next dose is only going to need doses from the last 24 hours, so that's what this method is limited to. Now that we have these interfaces, we can type-hint against them in our services.","title":"Step 1: Repo Interfaces"},{"location":"walkthrough/03-services/#step-2-management-services","text":"These are all pretty similar (and something I'm hoping to provide some shortcuts for in the future), so here's the idea: use Cavatappi\\Foundation\\Command\\{CommandHandler, CommandHandlerService}; use Cavatappi\\Foundation\\Exceptions\\{ActionNotAuthorized, InvalidValueProperties}; use Cavatappi\\Foundation\\Factories\\UuidFactory; use oddEvan\\PillTimer\\Commands\\AddMedicine; use oddEvan\\PillTimer\\Events\\MedicineAdded; use Psr\\EventDispatcher\\EventDispatcherInterface; class MedicineService implements CommandHandlerService { public function __construct( private MedicineRepo $repo, private EventDispatcherInterface $eventBus ) { } #[CommandHandler] public function addMedicine(AddMedicine $cmd): void { if ($this->repo->has($cmd->medicine->id)) { throw new InvalidValueProperties(\"A medicine with the ID {$cmd->medicine->id} already exists\"); } if (!$cmd->userId->equals($cmd->medicine->userId)) { throw new ActionNotAuthorized('You cannot create a Medicine for someone else.'); } $this->eventBus->dispatch(new MedicineAdded( medicine: $cmd->medicine, userId: $cmd->userId, )); } } First off, we declare dependencies in the constructor: the MedicineRepo we defined earlier along with an EventDispatcherInterface from PSR-14 , which we use to dispatch the event. As an example of a CommandHandler , we have one for the AddMedicine command. Remember, the only preconditions for a command object are It is a valid object according to its conditions, and If it is an Authenticated command, the userId property represents the user issuing the command. Everything else is domain-specific. So for PillTimer, we check: Is the ID already in use? This is a create method, so there shouldn't already be a Mediicne with this ID. Is the user authorized? For now, we're only checking if the user is creating a medicine for themselves. In the future we may call out to a separate service for more fine-grained permissions. If all the conditions are met, we should save the Medicine. To do that, we dispatch the MedicineAdded event and add the appropriate information. With that, the domain model's work is done, right? Eh, not quite.","title":"Step 2: Management Services"},{"location":"walkthrough/03-services/#step-3-ephemeral-data","text":"The idea behind an event-sourced system is to store the events with their necessary data; everything else is ephemeral. For PillTimer, that includes the time of the next dose. It's not something explicitly entered by the user, it's calculated using: The doses in the last 24 hours, The time allowed between doses, and The number of allowed doses per 24 hours. That's why, instead of having a \"Next Dose Time Set\" event, we have a method on the MedicineRepo to add the information to the Medicine object. Other methods could include keeping the information in a separate repository or calculating it on-the-fly every time it's needed. This method feels the most straightforward to me, at least right now. So how do we calculate this when we need to? We listen for any events that might change the next dose time and run our code then. There are two ways we could do this: List all the events to listen for in our service, or Declare an interface for all appropriate events to implement. I personally think that either method is valid, especially on a small app like this for an event intended to be used by its own domain model. The second feels like less typing, so I'm going to go with that one. First, we declare a new interface: interface ChangesNextDoseTime { public function doseTime(): ?DateTimeInterface; } We could have made it completely empty, but this will make the code simpler in our service without compromising the Events themselves. Next, we add the new interface to our existing events and implement the new method. For DoseAdded , it's simple: class DoseAdded implements DomainEvent, ChangesNextDoseTime { // ... public function doseTime(): ?DateTimeInterface { return $this->dose->timestamp; } } We would do the same for a DoseDeleted event (which is good to know since normally we wouldn't include info from the entity on an event deleting it). For MedicineAdded , though, we forgo the interface entirely. A new medicine won't have any doses, so it won't have a time for a next dose. MedicineUpdated , though, will, since it could change the timing: class MedicineUpdated implements DomainEvent, ChangesNextDoseTime { // ... public function doseTime(): ?DateTimeInterface { return null; } } Since there's no new dosage information, we return null . Once we've gotten all our events updated, we can create the new service: use Cavatappi\\Foundation\\DomainEvent\\EventListenerService; use Cavatappi\\Foundation\\DomainEvent\\ProjectionListener; use DateTimeImmutable; use oddEvan\\PillTimer\\Events\\ChangesNextDoseTime; class NextDoseService implements EventListenerService { public function __construct( private MedicineRepo $medicineRepo, private DoseRepo $doseRepo ) { } public const TWENTY_FOUR_HOURS = 24 * 60 * 60; #[ProjectionListener] public function recalculate(ChangesNextDoseTime $event) { $doseTime = $event->doseTime()?->getTimestamp() ?? null; if (isset($doseTime) && time() - $doseTime > self::TWENTY_FOUR_HOURS) { // A dose older than the last 24 hours was changed; we can safely ignore it. return; } $medicine = $this->medicineRepo->get($event->aggregateId); $doses = $this->doseRepo->dosesForMedicineInLastDay($event->aggregateId); usort($doses, fn($doseA, $doseB) => $doseA->timestamp->getTimestamp() - $doseB->timestamp->getTimestamp()); if (empty($doses)) { // No existing doses; we can safely ignore the event. return; } $this->medicineRepo->setNextDose( medicineId: $event->aggregateId, timestamp: self::calculate($doses, $medicine->hourlyInterval, $medicine->dailyLimit), ); } private static function calculate(array $doses, ?int $interval, ?int $limit): DateTimeImmutable { // idk; stuff? return new DateTimeImmutable(); } } (Yes, that's a placeholder.) There are two types of event listener attributes: EventListener and ProjectionListener . Both will be called when the given type-hinted event is dispatched. To save the whole event-sourcing conversation for later, we'll just say that a Projection-style listener shouldn't have side effects like calling other services, issuing commands, or the like. Since this is only calculating derived data, it's a Projection.","title":"Step 3: Ephemeral Data"},{"location":"walkthrough/03-services/#wrapup","text":"So that's a look at how Service classes work in Cavatappi. We're looking at incoming Commands, outgoing Events, and even consuming some of those downstream events. And all this means our system is now ready to test! Aren't you excited?","title":"Wrapup"},{"location":"walkthrough/04-tests/","text":"Tests We all know we should write them. We hardly ever do. One of my hopes with Cavatappi is to make tests easier to write. Part of that is architecting the application to make it testable, and the other part is having some shortcuts on hand to make the tests simpler and easier to run. Step 1: Set Up the Module To use some of the shortcuts that Cavatappi has for tests, we'll need to go ahead and set up the Module for our application. This is a special class that's responsible for providing a list of classes as well as a dependency map for the services. There's some useful shortcuts for this as well: use Cavatappi\\Foundation\\Module; use Cavatappi\\Foundation\\Module\\FileDiscoveryKit; use Cavatappi\\Foundation\\Module\\ModuleKit; class PillTimerBackend implements Module { use FileDiscoveryKit; use ModuleKit; private static function serviceMapOverrides(): array { return []; } } Not a lot here! Let's take a look at the actual Module interface: interface Module { /** * Array of class name keys with the interfaces they implement. * * @return array<class-string, class-string[]> */ public static function discoverableClasses(): array; /** * Get the Services to be registered in this Model and their dependencies. * * @return array<class-string, array<string, class-string|callable>|string|callable> */ public static function serviceDependencyMap(): array; } The heavy lifting is done by ModuleKit which implements the two interface methods using a pair of abstract functions: trait ModuleKit { //... /** * Get the list of discoverable classes in this Module. * * @return class-string[] */ abstract private static function listClasses(): array; /** * Get any overrides to the autogenerated service dependency map. * * @return array<class-string, array<string, class-string|callable>|string|callable> */ abstract private static function serviceMapOverrides(): array; //... } These take what is unique about your Module and handle the boilerplate: listClasses() provides a list of class names in your Module. The trait will add the interfaces the classes implement to fulfill the discoverableClasses() requirement. The trait uses the list of classes to find Service classes and automatically infer a dependency map for them. Any that cannot or should not be inferred should be provided in serviceMapOverrides() . The two are merged to fulfill the serviceDependencyMap() requirement. For our Module, the listClasses() function is implemented by the FileDiscoveryKit trait. By default, it will search its own folder and any sub-folders for concrete classes. (Behind the scenes this uses Construct Finder by The League of Extraordinary Packages .) We don't currently have any overrides for the dependency map. We might in the future if we have a class that implements a common interface or requires some configuration that can't be auto-inferred (yet). With this Module in place, our code is ready to be integrated with a Cavatappi app. Step 2: Install Test Utilities The only required part of this step is declaring the dependency: composer require --dev cavatappi/testing This is going to install a few things including Cavatappi's infrastructure package and PHPUnit . For convenience, I'll add a PHPUnit configuration file and another shortcut in composer.json : \"scripts\": { \"lint\": \"./vendor/squizlabs/php_codesniffer/bin/phpcs\", \"lintfix\": \"./vendor/squizlabs/php_codesniffer/bin/phpcbf\", \"test\": \"phpunit --testsuite unit --no-coverage\" } Finally, I'm going to add a couple of folders. The first, tests , will be where the actual tests go. The second, test-utils , is going to hold a superclass that will be used by most of the tests. We'll add that to our composer.json file: \"autoload-dev\": { \"psr-4\": { \"oddEvan\\\\PillTimer\\\\Test\": \"test-utils/\" } } Step 3: Set Up the Model Test Instead of a strict unit test (where we are only testing one specific service class), I'm going to demonstrate testing the domain model as a whole. Remember that a domain model accepts Command objects and outputs Event objects, and Cavatappi has a way to test exactly that. In our test-utils folder, I'll create a base test: use Cavatappi\\Test\\ModelTest; use oddEvan\\PillTimer\\PillTimerBackend; use oddEvan\\PillTimer\\Services\\DoseRepo; use oddEvan\\PillTimer\\Services\\MedicineRepo; use PHPUnit\\Framework\\MockObject\\MockObject; abstract class PillTimerTest extends ModelTest { const INCLUDED_MODELS = [PillTimerBackend::class]; protected DoseRepo & MockObject $doseRepo; protected MedicineRepo & MockObject $medRepo; protected function createMockServices(): array { $this->doseRepo = $this->createMock(DoseRepo::class); $this->medRepo = $this->createMock(MedicineRepo::class); return [ ...parent::createMockServices(), DoseRepo::class => fn() => $this->doseRepo, MedicineRepo::class => fn() => $this->medRepo, ]; } } This sets up two mock services for the repository interfaces we created but never implemented. They're class-level objects, so we can set conditions on each test. Behind the scenes, Cavatappi will add the result of createMockServices() to the usual output of our PillTimerBackend Module class as well as its internal test module and create an instance of ServiceRegistry , Cavatappi's dependency injection container. This way, our tests will confirm that our Module is fully functional as a whole. Astute readers will note that we will be writing integration tests and not unit tests. We can get into testing philosophy whenever, but my personal take is that we are always testing input and results . Which input and which results should be whatever gives us the most confidence in our code. In the case of a domain model-driven application, I consider that the Commands and Events. The actual makeup of the services doesn't matter as much as a given command resulting in the given events. Step 4: Write a Model Test Enough messing around, let's write a test! We'll start with our AddMedicine Command: use oddEvan\\PillTimer\\Entities\\Medicine; use oddEvan\\PillTimer\\Events\\MedicineAdded; use oddEvan\\PillTimer\\Test\\PillTimerTest; final class AddMedicineTest extends PillTimerTest { private Medicine $testMed; protected function setUp(): void { parent::setUp(); $this->testMed = new Medicine( name: 'Acetaminophen', userId: $this->randomId(), hourlyInterval: 6, dailyLimit: 3, ); } public function testItCreatesTheMedicine() { // Medicine does not already exist. $this->medRepo->method('has')->with($this->testMed->id)->willReturn(false); $this->expectEvent(new MedicineAdded( medicine: $this->testMed, userId: $this->testMed->userId, )); $this->app->execute(new AddMedicine( medicine: $this->testMed, userId: $this->testMed->userId, )); } } Not much here, and that's by design! We set up one stub method on our Medicine repository and one expected Event. We then create the Command and pass it to the test app's execute() method. By using a ModelTest subclass, we already have a mock set up for EventDispatcherInterface as well as a custom PHPUnit comparator to check that two Event objects are equal except for their IDs and timestamps. We can run the test using the shortcut we set up, composer test , and see that it passes: Add Medicine (oddEvan\\PillTimer\\Commands\\AddMedicine) \u2714 It creates the medicine Step 5: Write an App Test Now, what about our NextDoseService ? Since it responds to an Event and not a Command, we can't use ModelTest . So for this one, we'll go up one level to AppTest . We don't need to set up a superclass in this case: use Cavatappi\\Test\\AppTest; use DateTimeImmutable; use oddEvan\\PillTimer\\Entities\\Dose; use oddEvan\\PillTimer\\Entities\\Medicine; use oddEvan\\PillTimer\\Events\\DoseAdded; use oddEvan\\PillTimer\\PillTimerBackend; use PHPUnit\\Framework\\MockObject\\MockObject; final class NextDoseServiceTest extends AppTest { const INCLUDED_MODELS = [PillTimerBackend::class]; protected DoseRepo & MockObject $doseRepo; protected MedicineRepo & MockObject $medRepo; protected function createMockServices(): array { $this->doseRepo = $this->createMock(DoseRepo::class); $this->medRepo = $this->createMock(MedicineRepo::class); return [ ...parent::createMockServices(), DoseRepo::class => fn() => $this->doseRepo, MedicineRepo::class => fn() => $this->medRepo, ]; } public function testItCalculatesTheNextDoseCorrectly() { $baseTimestamp = new DateTimeImmutable('@' . time(), timezone_open('America/New_York')); $medicine = new Medicine( name: 'Ibuprofen', userId: $this->randomId(), hourlyInterval: 4, dailyLimit: 3, ); $this->medRepo->method('get')->with(medicineId: $medicine->id)->willReturn($medicine); $existingDoses = []; $this->doseRepo->method('dosesForMedicineInLastDay')-> with(medicineId: $medicine->id)->willReturn($existingDoses); $newDose = new Dose( id: $this->randomId(), medicineId: $medicine->id, timestamp: $baseTimestamp, ); $expected = $baseTimestamp->modify('+4 hours'); $this->medRepo->expects($this->once())->method('setNextDose')->with($medicine->id, $expected); $this->app->dispatch(new DoseAdded( dose: $newDose, userId: $medicine->userId, )); } } ...there's a lot of copypasta in there. Siri, make a new GitHub issue to refactor ModelTest into a trait. I've also set this up to eventually refactor the test into something repeatable using PHPUnit's data providers . This test in particular is going to involve a lot of repetitive set up to make sure that this calculation is being done correctly. So that's an overview of how Cavatappi makes testing suck less. And hopefully, as the framework improves, this will as well! And that's our walkthrough of Cavatappi! We haven't built a complete app yet; there's still more to be done around data persistence (saving to the database), creating API endpoints, and maybe building an admin UI. There's more to come, but that's what we have so far. Thanks for reading!","title":"Tests"},{"location":"walkthrough/04-tests/#tests","text":"We all know we should write them. We hardly ever do. One of my hopes with Cavatappi is to make tests easier to write. Part of that is architecting the application to make it testable, and the other part is having some shortcuts on hand to make the tests simpler and easier to run.","title":"Tests"},{"location":"walkthrough/04-tests/#step-1-set-up-the-module","text":"To use some of the shortcuts that Cavatappi has for tests, we'll need to go ahead and set up the Module for our application. This is a special class that's responsible for providing a list of classes as well as a dependency map for the services. There's some useful shortcuts for this as well: use Cavatappi\\Foundation\\Module; use Cavatappi\\Foundation\\Module\\FileDiscoveryKit; use Cavatappi\\Foundation\\Module\\ModuleKit; class PillTimerBackend implements Module { use FileDiscoveryKit; use ModuleKit; private static function serviceMapOverrides(): array { return []; } } Not a lot here! Let's take a look at the actual Module interface: interface Module { /** * Array of class name keys with the interfaces they implement. * * @return array<class-string, class-string[]> */ public static function discoverableClasses(): array; /** * Get the Services to be registered in this Model and their dependencies. * * @return array<class-string, array<string, class-string|callable>|string|callable> */ public static function serviceDependencyMap(): array; } The heavy lifting is done by ModuleKit which implements the two interface methods using a pair of abstract functions: trait ModuleKit { //... /** * Get the list of discoverable classes in this Module. * * @return class-string[] */ abstract private static function listClasses(): array; /** * Get any overrides to the autogenerated service dependency map. * * @return array<class-string, array<string, class-string|callable>|string|callable> */ abstract private static function serviceMapOverrides(): array; //... } These take what is unique about your Module and handle the boilerplate: listClasses() provides a list of class names in your Module. The trait will add the interfaces the classes implement to fulfill the discoverableClasses() requirement. The trait uses the list of classes to find Service classes and automatically infer a dependency map for them. Any that cannot or should not be inferred should be provided in serviceMapOverrides() . The two are merged to fulfill the serviceDependencyMap() requirement. For our Module, the listClasses() function is implemented by the FileDiscoveryKit trait. By default, it will search its own folder and any sub-folders for concrete classes. (Behind the scenes this uses Construct Finder by The League of Extraordinary Packages .) We don't currently have any overrides for the dependency map. We might in the future if we have a class that implements a common interface or requires some configuration that can't be auto-inferred (yet). With this Module in place, our code is ready to be integrated with a Cavatappi app.","title":"Step 1: Set Up the Module"},{"location":"walkthrough/04-tests/#step-2-install-test-utilities","text":"The only required part of this step is declaring the dependency: composer require --dev cavatappi/testing This is going to install a few things including Cavatappi's infrastructure package and PHPUnit . For convenience, I'll add a PHPUnit configuration file and another shortcut in composer.json : \"scripts\": { \"lint\": \"./vendor/squizlabs/php_codesniffer/bin/phpcs\", \"lintfix\": \"./vendor/squizlabs/php_codesniffer/bin/phpcbf\", \"test\": \"phpunit --testsuite unit --no-coverage\" } Finally, I'm going to add a couple of folders. The first, tests , will be where the actual tests go. The second, test-utils , is going to hold a superclass that will be used by most of the tests. We'll add that to our composer.json file: \"autoload-dev\": { \"psr-4\": { \"oddEvan\\\\PillTimer\\\\Test\": \"test-utils/\" } }","title":"Step 2: Install Test Utilities"},{"location":"walkthrough/04-tests/#step-3-set-up-the-model-test","text":"Instead of a strict unit test (where we are only testing one specific service class), I'm going to demonstrate testing the domain model as a whole. Remember that a domain model accepts Command objects and outputs Event objects, and Cavatappi has a way to test exactly that. In our test-utils folder, I'll create a base test: use Cavatappi\\Test\\ModelTest; use oddEvan\\PillTimer\\PillTimerBackend; use oddEvan\\PillTimer\\Services\\DoseRepo; use oddEvan\\PillTimer\\Services\\MedicineRepo; use PHPUnit\\Framework\\MockObject\\MockObject; abstract class PillTimerTest extends ModelTest { const INCLUDED_MODELS = [PillTimerBackend::class]; protected DoseRepo & MockObject $doseRepo; protected MedicineRepo & MockObject $medRepo; protected function createMockServices(): array { $this->doseRepo = $this->createMock(DoseRepo::class); $this->medRepo = $this->createMock(MedicineRepo::class); return [ ...parent::createMockServices(), DoseRepo::class => fn() => $this->doseRepo, MedicineRepo::class => fn() => $this->medRepo, ]; } } This sets up two mock services for the repository interfaces we created but never implemented. They're class-level objects, so we can set conditions on each test. Behind the scenes, Cavatappi will add the result of createMockServices() to the usual output of our PillTimerBackend Module class as well as its internal test module and create an instance of ServiceRegistry , Cavatappi's dependency injection container. This way, our tests will confirm that our Module is fully functional as a whole. Astute readers will note that we will be writing integration tests and not unit tests. We can get into testing philosophy whenever, but my personal take is that we are always testing input and results . Which input and which results should be whatever gives us the most confidence in our code. In the case of a domain model-driven application, I consider that the Commands and Events. The actual makeup of the services doesn't matter as much as a given command resulting in the given events.","title":"Step 3: Set Up the Model Test"},{"location":"walkthrough/04-tests/#step-4-write-a-model-test","text":"Enough messing around, let's write a test! We'll start with our AddMedicine Command: use oddEvan\\PillTimer\\Entities\\Medicine; use oddEvan\\PillTimer\\Events\\MedicineAdded; use oddEvan\\PillTimer\\Test\\PillTimerTest; final class AddMedicineTest extends PillTimerTest { private Medicine $testMed; protected function setUp(): void { parent::setUp(); $this->testMed = new Medicine( name: 'Acetaminophen', userId: $this->randomId(), hourlyInterval: 6, dailyLimit: 3, ); } public function testItCreatesTheMedicine() { // Medicine does not already exist. $this->medRepo->method('has')->with($this->testMed->id)->willReturn(false); $this->expectEvent(new MedicineAdded( medicine: $this->testMed, userId: $this->testMed->userId, )); $this->app->execute(new AddMedicine( medicine: $this->testMed, userId: $this->testMed->userId, )); } } Not much here, and that's by design! We set up one stub method on our Medicine repository and one expected Event. We then create the Command and pass it to the test app's execute() method. By using a ModelTest subclass, we already have a mock set up for EventDispatcherInterface as well as a custom PHPUnit comparator to check that two Event objects are equal except for their IDs and timestamps. We can run the test using the shortcut we set up, composer test , and see that it passes: Add Medicine (oddEvan\\PillTimer\\Commands\\AddMedicine) \u2714 It creates the medicine","title":"Step 4: Write a Model Test"},{"location":"walkthrough/04-tests/#step-5-write-an-app-test","text":"Now, what about our NextDoseService ? Since it responds to an Event and not a Command, we can't use ModelTest . So for this one, we'll go up one level to AppTest . We don't need to set up a superclass in this case: use Cavatappi\\Test\\AppTest; use DateTimeImmutable; use oddEvan\\PillTimer\\Entities\\Dose; use oddEvan\\PillTimer\\Entities\\Medicine; use oddEvan\\PillTimer\\Events\\DoseAdded; use oddEvan\\PillTimer\\PillTimerBackend; use PHPUnit\\Framework\\MockObject\\MockObject; final class NextDoseServiceTest extends AppTest { const INCLUDED_MODELS = [PillTimerBackend::class]; protected DoseRepo & MockObject $doseRepo; protected MedicineRepo & MockObject $medRepo; protected function createMockServices(): array { $this->doseRepo = $this->createMock(DoseRepo::class); $this->medRepo = $this->createMock(MedicineRepo::class); return [ ...parent::createMockServices(), DoseRepo::class => fn() => $this->doseRepo, MedicineRepo::class => fn() => $this->medRepo, ]; } public function testItCalculatesTheNextDoseCorrectly() { $baseTimestamp = new DateTimeImmutable('@' . time(), timezone_open('America/New_York')); $medicine = new Medicine( name: 'Ibuprofen', userId: $this->randomId(), hourlyInterval: 4, dailyLimit: 3, ); $this->medRepo->method('get')->with(medicineId: $medicine->id)->willReturn($medicine); $existingDoses = []; $this->doseRepo->method('dosesForMedicineInLastDay')-> with(medicineId: $medicine->id)->willReturn($existingDoses); $newDose = new Dose( id: $this->randomId(), medicineId: $medicine->id, timestamp: $baseTimestamp, ); $expected = $baseTimestamp->modify('+4 hours'); $this->medRepo->expects($this->once())->method('setNextDose')->with($medicine->id, $expected); $this->app->dispatch(new DoseAdded( dose: $newDose, userId: $medicine->userId, )); } } ...there's a lot of copypasta in there. Siri, make a new GitHub issue to refactor ModelTest into a trait. I've also set this up to eventually refactor the test into something repeatable using PHPUnit's data providers . This test in particular is going to involve a lot of repetitive set up to make sure that this calculation is being done correctly. So that's an overview of how Cavatappi makes testing suck less. And hopefully, as the framework improves, this will as well! And that's our walkthrough of Cavatappi! We haven't built a complete app yet; there's still more to be done around data persistence (saving to the database), creating API endpoints, and maybe building an admin UI. There's more to come, but that's what we have so far. Thanks for reading!","title":"Step 5: Write an App Test"}]}