{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Cavatappi PHP Framework Documentation This is the documentation for the Cavatappi framework. For a general overview of the framework philosophy (the \"why\"), start with About the Framework . For a look at where things are going, see the Roadmap . For detailed info on how to use the framework, browse Packages . For a good time, call Strong Bad .","title":"Cavatappi PHP Framework Documentation"},{"location":"#cavatappi-php-framework-documentation","text":"This is the documentation for the Cavatappi framework. For a general overview of the framework philosophy (the \"why\"), start with About the Framework . For a look at where things are going, see the Roadmap . For detailed info on how to use the framework, browse Packages . For a good time, call Strong Bad .","title":"Cavatappi PHP Framework Documentation"},{"location":"about/","text":"About Cavatappi I'll assume you already know the benefits of using a framework, but if you don't, the TL;DR is less boilerplate code for you to write and maintain, which leaves you more time to focus on your app. So when I tell you that instead of using any of the existing frameworks I decided to build my own, you should have at least one question: Why? But Why? The short answer is because I wanted to. To elaborate, I was working on a big project with a small name and wanted to truly understand what my code was doing. I wanted to put the object-oriented lessons I was finally understanding into practice. I wanted something testable, portable, and lightweight. And I had just enough of a grasp of the modern PHP ecosystem to feel like I could do it, but not enough experience to tell me not to. This does beg another question: why should you use Cavatappi? Let me be a little blunt: you shouldn't. Don't use this Cavatappi, while born out of an existing project, does not currently have a production app to showcase it. It's ready for me to show the world, but it's not in a place where I'm comfortable using it for real production work. That being said, if the ideas on this site resonate with you and you want to help out, check out the GitHub repo and see what you can contribute. Why the name, though? I don't like cut-and-paste code. Lots of boilerplate tells me there's a chance for an abstraction, or at least a way to provide some sane defaults. So that's why the framework is named after a pasta: because I don't like copypasta. I chose this specific pasta because... The domain name was available, and It kinda looks like a snake. Thus, Cavatappi. Axioms Yes, it's reductive, but it helps get the ideas across. So here's some guiding principles for the Cavatappi framework: Defaults, not Dogma : Build features and abstractions so that simple apps can be written with minimal code, but deviations from the norm don't require re-implementing the entire feature. Try to maximize what can be done before a developer needs to abandon the framework's abstraction entirely. Signals, not Magic : Use explicit signals like PHP's type system and annotations to opt into behavior. Don't change the framework's behavior because a file is in a particular folder or a parameter has a particular name. The Basic Idea The basis for Cavatappi is that every class is either a Value or a Service : Value objects are (generally) immutable and used to store structured data. They should have no dependencies and be internally consistent. Value objects house state , not logic. Service objects are (generally) stateless and used to perform operations. They are given the dependencies they need at construction in order to work with structured data. Service objects house logic , not state. The Details Cavatappi takes this overall philosophy and uses it to help you build a well-organized app. Some other concepts make their way in, like: Registries : Find all classes that implement a particular interface and store information about them in a central location. This is currently the way to introduce extendability into applications. Commands and Events : Build a Domain Model that takes Command objects as input and dispatches Event objects with the result. Reflection : Use PHP's type system and annotations to build a meta-picture of classes that can be used to inform application behavior. Domain-driven Design : Isolate core application logic from general application concerns. Downstream Libraries Despite the foolishness of this endeavor, Cavatappi does build off several existing PHP libraries: Tukio and Serde by Larry Garfield ramsey/uuid by Ben Ramsey Construct Finder by The League of Extraordinary Packages nyholm/psr7 by Tobias Nyholm and Martijn van der Ven PHPUnit by Sebastian Bergmann","title":"About"},{"location":"about/#about-cavatappi","text":"I'll assume you already know the benefits of using a framework, but if you don't, the TL;DR is less boilerplate code for you to write and maintain, which leaves you more time to focus on your app. So when I tell you that instead of using any of the existing frameworks I decided to build my own, you should have at least one question:","title":"About Cavatappi"},{"location":"about/#why","text":"But Why? The short answer is because I wanted to. To elaborate, I was working on a big project with a small name and wanted to truly understand what my code was doing. I wanted to put the object-oriented lessons I was finally understanding into practice. I wanted something testable, portable, and lightweight. And I had just enough of a grasp of the modern PHP ecosystem to feel like I could do it, but not enough experience to tell me not to. This does beg another question: why should you use Cavatappi? Let me be a little blunt: you shouldn't.","title":"Why?"},{"location":"about/#dont-use-this","text":"Cavatappi, while born out of an existing project, does not currently have a production app to showcase it. It's ready for me to show the world, but it's not in a place where I'm comfortable using it for real production work. That being said, if the ideas on this site resonate with you and you want to help out, check out the GitHub repo and see what you can contribute.","title":"Don't use this"},{"location":"about/#why-the-name-though","text":"I don't like cut-and-paste code. Lots of boilerplate tells me there's a chance for an abstraction, or at least a way to provide some sane defaults. So that's why the framework is named after a pasta: because I don't like copypasta. I chose this specific pasta because... The domain name was available, and It kinda looks like a snake. Thus, Cavatappi.","title":"Why the name, though?"},{"location":"about/#axioms","text":"Yes, it's reductive, but it helps get the ideas across. So here's some guiding principles for the Cavatappi framework: Defaults, not Dogma : Build features and abstractions so that simple apps can be written with minimal code, but deviations from the norm don't require re-implementing the entire feature. Try to maximize what can be done before a developer needs to abandon the framework's abstraction entirely. Signals, not Magic : Use explicit signals like PHP's type system and annotations to opt into behavior. Don't change the framework's behavior because a file is in a particular folder or a parameter has a particular name.","title":"Axioms"},{"location":"about/#the-basic-idea","text":"The basis for Cavatappi is that every class is either a Value or a Service : Value objects are (generally) immutable and used to store structured data. They should have no dependencies and be internally consistent. Value objects house state , not logic. Service objects are (generally) stateless and used to perform operations. They are given the dependencies they need at construction in order to work with structured data. Service objects house logic , not state.","title":"The Basic Idea"},{"location":"about/#the-details","text":"Cavatappi takes this overall philosophy and uses it to help you build a well-organized app. Some other concepts make their way in, like: Registries : Find all classes that implement a particular interface and store information about them in a central location. This is currently the way to introduce extendability into applications. Commands and Events : Build a Domain Model that takes Command objects as input and dispatches Event objects with the result. Reflection : Use PHP's type system and annotations to build a meta-picture of classes that can be used to inform application behavior. Domain-driven Design : Isolate core application logic from general application concerns.","title":"The Details"},{"location":"about/#downstream-libraries","text":"Despite the foolishness of this endeavor, Cavatappi does build off several existing PHP libraries: Tukio and Serde by Larry Garfield ramsey/uuid by Ben Ramsey Construct Finder by The League of Extraordinary Packages nyholm/psr7 by Tobias Nyholm and Martijn van der Ven PHPUnit by Sebastian Bergmann","title":"Downstream Libraries"},{"location":"roadmap/","text":"Roadmap Everything is subject to change. Even this. Especially this. Current This is what's in the framework now Dependency Injection Using a stupidly simple container . Register Services automatically. Set up concrete implementations of interfaces and abstract classes. Registries Surfacing a class to the system is as simple as implements Interface . Register different adapters, add services to the dependency injection container, or other uses. Commands and Events Using a custom-built Command Bus and Tukio for event dispatching. Define a domain model with Commands as input and Events as output. Auto-register Command handlers and Event listeners. Sets up event sourcing for data persistence. Version 1 This is what I would consider the needed feature set before calling the framework ready for general use. API Set up a registry and configuration for an Endpoint class so that endpoints can be auto-registered. Use reflection tools to generate an OpenAPI (or similar) spec. Integrate with (or provide adapter to) something like Slim to handle routing. Markdown Registry system for Markdown customizations. Data Persistence Make it as easy to do event sourcing as most frameworks make CRUD . Registry for database tables. Integrate with Doctrine DBAL . Authentication Integrate with some library (what's the PHP equivalent to Omniauth ?) Create extendable User entity Some kind of OAuth or JWT scheme to secure APIs Make this effortless. Like, really effortless. Like works-out-of-the-box effortless. Further Enhancements The lofty ideas of things beyond version 1. UI Framework Build encapsulated UI components in PHP Use other design systems as a base and layer customizations on top Use reflection to make a form builder. Or just make a form builder. Seriously, can I have a form builder? Static Site Generation Have a way to generate HTML pages and save them to disk. Useful for making landing pages or outputting a single-page app Build System Generate hard-coded configurations and setups for Registries and other high-use classes. Optimize the system when it's in a stable place (staging/production) without compromising development speed. Allow other systems to hook in for generating documentation, web pages, etc. Smolblog That is why this whole thing started.","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"Everything is subject to change. Even this. Especially this.","title":"Roadmap"},{"location":"roadmap/#current","text":"This is what's in the framework now","title":"Current"},{"location":"roadmap/#dependency-injection","text":"Using a stupidly simple container . Register Services automatically. Set up concrete implementations of interfaces and abstract classes.","title":"Dependency Injection"},{"location":"roadmap/#registries","text":"Surfacing a class to the system is as simple as implements Interface . Register different adapters, add services to the dependency injection container, or other uses.","title":"Registries"},{"location":"roadmap/#commands-and-events","text":"Using a custom-built Command Bus and Tukio for event dispatching. Define a domain model with Commands as input and Events as output. Auto-register Command handlers and Event listeners. Sets up event sourcing for data persistence.","title":"Commands and Events"},{"location":"roadmap/#version-1","text":"This is what I would consider the needed feature set before calling the framework ready for general use.","title":"Version 1"},{"location":"roadmap/#api","text":"Set up a registry and configuration for an Endpoint class so that endpoints can be auto-registered. Use reflection tools to generate an OpenAPI (or similar) spec. Integrate with (or provide adapter to) something like Slim to handle routing.","title":"API"},{"location":"roadmap/#markdown","text":"Registry system for Markdown customizations.","title":"Markdown"},{"location":"roadmap/#data-persistence","text":"Make it as easy to do event sourcing as most frameworks make CRUD . Registry for database tables. Integrate with Doctrine DBAL .","title":"Data Persistence"},{"location":"roadmap/#authentication","text":"Integrate with some library (what's the PHP equivalent to Omniauth ?) Create extendable User entity Some kind of OAuth or JWT scheme to secure APIs Make this effortless. Like, really effortless. Like works-out-of-the-box effortless.","title":"Authentication"},{"location":"roadmap/#further-enhancements","text":"The lofty ideas of things beyond version 1.","title":"Further Enhancements"},{"location":"roadmap/#ui-framework","text":"Build encapsulated UI components in PHP Use other design systems as a base and layer customizations on top Use reflection to make a form builder. Or just make a form builder. Seriously, can I have a form builder?","title":"UI Framework"},{"location":"roadmap/#static-site-generation","text":"Have a way to generate HTML pages and save them to disk. Useful for making landing pages or outputting a single-page app","title":"Static Site Generation"},{"location":"roadmap/#build-system","text":"Generate hard-coded configurations and setups for Registries and other high-use classes. Optimize the system when it's in a stable place (staging/production) without compromising development speed. Allow other systems to hook in for generating documentation, web pages, etc.","title":"Build System"},{"location":"roadmap/#smolblog","text":"That is why this whole thing started.","title":"Smolblog"},{"location":"packages/","text":"Packages Foundation Everything you need to define and build a Domain Model. Infrastructure Application-level utilities and services. Testing Because you need to write tests. Yes, you. And you.","title":"Packages"},{"location":"packages/#packages","text":"Foundation Everything you need to define and build a Domain Model. Infrastructure Application-level utilities and services. Testing Because you need to write tests. Yes, you. And you.","title":"Packages"},{"location":"packages/foundation/","text":"Cavatappi Foundation Base-level interfaces and traits for defining a domain model. Installation composer require cavatappi/foundation","title":"Cavatappi Foundation"},{"location":"packages/foundation/#cavatappi-foundation","text":"Base-level interfaces and traits for defining a domain model.","title":"Cavatappi Foundation"},{"location":"packages/foundation/#installation","text":"composer require cavatappi/foundation","title":"Installation"},{"location":"packages/infrastructure/","text":"Cavatappi Foundation Application-level services. Installation composer require cavatappi/infrastructure","title":"Cavatappi Foundation"},{"location":"packages/infrastructure/#cavatappi-foundation","text":"Application-level services.","title":"Cavatappi Foundation"},{"location":"packages/infrastructure/#installation","text":"composer require cavatappi/infrastructure","title":"Installation"},{"location":"packages/testing/","text":"Cavatappi Test Utilities Make tests suck less. Because you need to write them. Yes, you. Installation composer require --dev cavatappi/testing","title":"Cavatappi Test Utilities"},{"location":"packages/testing/#cavatappi-test-utilities","text":"Make tests suck less. Because you need to write them. Yes, you.","title":"Cavatappi Test Utilities"},{"location":"packages/testing/#installation","text":"composer require --dev cavatappi/testing","title":"Installation"},{"location":"walkthrough/","text":"Cavatappi Walkthrough It's not a tutorial, mostly because this is me solving a personal problem and bringing you, the reader, along for the ride. This is happening in near-real-time, so there might be some hiccups along the way. For this, I'll be making a backend for a web version of my iOS app, PillTimer . It's a simple app that tracks medicine doses and calculates when your next dose is. It's the kind of simple but feature-complete app I hope that Cavatappi can excel at, so lets give it a shot! Setup Initialize Composer and install the packages. Values Learn about how Value objects work in Cavatappi. More chapters to come as the app and framework mature.","title":"Intro"},{"location":"walkthrough/#cavatappi-walkthrough","text":"It's not a tutorial, mostly because this is me solving a personal problem and bringing you, the reader, along for the ride. This is happening in near-real-time, so there might be some hiccups along the way. For this, I'll be making a backend for a web version of my iOS app, PillTimer . It's a simple app that tracks medicine doses and calculates when your next dose is. It's the kind of simple but feature-complete app I hope that Cavatappi can excel at, so lets give it a shot! Setup Initialize Composer and install the packages. Values Learn about how Value objects work in Cavatappi. More chapters to come as the app and framework mature.","title":"Cavatappi Walkthrough"},{"location":"walkthrough/01-setup/","text":"Setup This is mostly setting up Composer with the Cavatappi packages and some extra tricks I like to have. Step 1: composer init Yeah, I'm basic. I've already got Composer installed via Homebrew , so I'll run its built-in step-by-step initializer: brew install composer composer init I'm only going to use the Foundation package for now while things get set up. And while Cavatappi itself uses the ASF license , I'm going to restrict this project's code to the GNU Affero GPL license . (That being said, all code samples in the documentation are public domain via CC0 , so reuse and modify anything you see here for whatever purpose you want!) At the end, I'll have a composer.json file that looks something like this: { \"name\": \"oddevan/pilltimer\", \"description\": \"Backend for the web version of PillTimer\", \"type\": \"project\", \"require\": { \"cavatappi/foundation\": \"^0.1.0\" }, \"license\": \"AGPL-3.0\", \"autoload\": { \"psr-4\": { \"oddEvan\\\\PillTimer\\\\\": \"src/\" } }, \"authors\": [ { \"name\": \"Evan Hildreth\", \"email\": \"me@eph.me\" } ] } Normally in a Composer project we would need to include the autoloader, but we're not there yet. And we won't be for some time. Step 2: Standards and Practices I like having some reasonable coding standards in place, if only because it means I can auto-format my code. Because this is a personal project and not necessarily intended for other developers to build off of, I'm mostly going to limit the included standards to code formatting and forgo the more documentation-heavy ones. I use [PHP_CodeSniffer] mostly because that's what dominates the WordPress ecosystem and therefore what I learned first. composer require --dev squizlabs/php_codesniffer And then add a .phpcs.xml config file that looks like this (suspiciously similar to Cavatappi's): <?xml version=\"1.0\"?> <ruleset name=\"PillTimer Standards\" namespace=\"oddEvan\\PillTimer\"> <description>Coding standards for PillTimer.</description> <file>./src</file> <exclude-pattern>*/src-test/*</exclude-pattern> <exclude-pattern>*/tests/*</exclude-pattern> <arg name=\"extensions\" value=\"php\"/> <arg name=\"tab-width\" value=\"2\"/> <arg name=\"colors\"/> <arg value=\"s\"/> <ini name=\"memory_limit\" value=\"64M\"/> <autoload>./vendor/autoload.php</autoload> <!-- Use PSR-12 as our base --> <rule ref=\"PSR12\"> <exclude name=\"Generic.WhiteSpace.DisallowTabIndent\"/> <exclude name=\"Generic.WhiteSpace.ScopeIndent\"/> <exclude name=\"PSR2.Classes.ClassDeclaration.OpenBraceNewLine\"/> <exclude name=\"PSR2.Methods.FunctionCallSignature.Indent\"/> <exclude name=\"Squiz.Functions.MultiLineFunctionDeclaration.BraceOnSameLine\"/> <exclude name=\"Squiz.Functions.MultiLineFunctionDeclaration.Indent\"/> </rule> <rule ref=\"PSR2.Methods.FunctionCallSignature.Indent\"> <properties> <property name=\"indent\" value=\"2\"/> </properties> </rule> <!-- Use tabs, please. Please. Seriously. --> <!-- https://alexandersandberg.com/articles/default-to-tabs-instead-of-spaces-for-an-accessible-first-environment/ --> <rule ref=\"Generic.WhiteSpace.DisallowSpaceIndent\"/> <rule ref=\"Generic.WhiteSpace.ScopeIndent\"> <properties> <property name=\"indent\" value=\"2\"/> <property name=\"tabIndent\" value=\"true\"/> <property name=\"ignoreIndentationTokens\" type=\"array\"> <element value=\"T_COMMENT\"/> <element value=\"T_DOC_COMMENT_OPEN_TAG\"/> </property> </properties> </rule> <!-- Make structures look nicer --> <rule ref=\"Generic.Classes.OpeningBraceSameLine\"/> <rule ref=\"Generic.Functions.OpeningFunctionBraceKernighanRitchie\"/> </ruleset> That's enough to tie into my code editor, but I like having some command line shortcuts, especially when it comes to auto-formatting. I'll add this to my composer.json file: \"scripts\": { \"lint\": \"./vendor/squizlabs/php_codesniffer/bin/phpcs\", \"lintfix\": \"./vendor/squizlabs/php_codesniffer/bin/phpcbf\" } OK, enough messing around. On to the next step: defining our data model !","title":"Setup"},{"location":"walkthrough/01-setup/#setup","text":"This is mostly setting up Composer with the Cavatappi packages and some extra tricks I like to have.","title":"Setup"},{"location":"walkthrough/01-setup/#step-1-composer-init","text":"Yeah, I'm basic. I've already got Composer installed via Homebrew , so I'll run its built-in step-by-step initializer: brew install composer composer init I'm only going to use the Foundation package for now while things get set up. And while Cavatappi itself uses the ASF license , I'm going to restrict this project's code to the GNU Affero GPL license . (That being said, all code samples in the documentation are public domain via CC0 , so reuse and modify anything you see here for whatever purpose you want!) At the end, I'll have a composer.json file that looks something like this: { \"name\": \"oddevan/pilltimer\", \"description\": \"Backend for the web version of PillTimer\", \"type\": \"project\", \"require\": { \"cavatappi/foundation\": \"^0.1.0\" }, \"license\": \"AGPL-3.0\", \"autoload\": { \"psr-4\": { \"oddEvan\\\\PillTimer\\\\\": \"src/\" } }, \"authors\": [ { \"name\": \"Evan Hildreth\", \"email\": \"me@eph.me\" } ] } Normally in a Composer project we would need to include the autoloader, but we're not there yet. And we won't be for some time.","title":"Step 1: composer init"},{"location":"walkthrough/01-setup/#step-2-standards-and-practices","text":"I like having some reasonable coding standards in place, if only because it means I can auto-format my code. Because this is a personal project and not necessarily intended for other developers to build off of, I'm mostly going to limit the included standards to code formatting and forgo the more documentation-heavy ones. I use [PHP_CodeSniffer] mostly because that's what dominates the WordPress ecosystem and therefore what I learned first. composer require --dev squizlabs/php_codesniffer And then add a .phpcs.xml config file that looks like this (suspiciously similar to Cavatappi's): <?xml version=\"1.0\"?> <ruleset name=\"PillTimer Standards\" namespace=\"oddEvan\\PillTimer\"> <description>Coding standards for PillTimer.</description> <file>./src</file> <exclude-pattern>*/src-test/*</exclude-pattern> <exclude-pattern>*/tests/*</exclude-pattern> <arg name=\"extensions\" value=\"php\"/> <arg name=\"tab-width\" value=\"2\"/> <arg name=\"colors\"/> <arg value=\"s\"/> <ini name=\"memory_limit\" value=\"64M\"/> <autoload>./vendor/autoload.php</autoload> <!-- Use PSR-12 as our base --> <rule ref=\"PSR12\"> <exclude name=\"Generic.WhiteSpace.DisallowTabIndent\"/> <exclude name=\"Generic.WhiteSpace.ScopeIndent\"/> <exclude name=\"PSR2.Classes.ClassDeclaration.OpenBraceNewLine\"/> <exclude name=\"PSR2.Methods.FunctionCallSignature.Indent\"/> <exclude name=\"Squiz.Functions.MultiLineFunctionDeclaration.BraceOnSameLine\"/> <exclude name=\"Squiz.Functions.MultiLineFunctionDeclaration.Indent\"/> </rule> <rule ref=\"PSR2.Methods.FunctionCallSignature.Indent\"> <properties> <property name=\"indent\" value=\"2\"/> </properties> </rule> <!-- Use tabs, please. Please. Seriously. --> <!-- https://alexandersandberg.com/articles/default-to-tabs-instead-of-spaces-for-an-accessible-first-environment/ --> <rule ref=\"Generic.WhiteSpace.DisallowSpaceIndent\"/> <rule ref=\"Generic.WhiteSpace.ScopeIndent\"> <properties> <property name=\"indent\" value=\"2\"/> <property name=\"tabIndent\" value=\"true\"/> <property name=\"ignoreIndentationTokens\" type=\"array\"> <element value=\"T_COMMENT\"/> <element value=\"T_DOC_COMMENT_OPEN_TAG\"/> </property> </properties> </rule> <!-- Make structures look nicer --> <rule ref=\"Generic.Classes.OpeningBraceSameLine\"/> <rule ref=\"Generic.Functions.OpeningFunctionBraceKernighanRitchie\"/> </ruleset> That's enough to tie into my code editor, but I like having some command line shortcuts, especially when it comes to auto-formatting. I'll add this to my composer.json file: \"scripts\": { \"lint\": \"./vendor/squizlabs/php_codesniffer/bin/phpcs\", \"lintfix\": \"./vendor/squizlabs/php_codesniffer/bin/phpcbf\" } OK, enough messing around. On to the next step: defining our data model !","title":"Step 2: Standards and Practices"},{"location":"walkthrough/02-values/","text":"Let's set up some initial Value objects to represent the data we need. Step 0: Figure out what we need A little bit of planning goes a long way. So let me think out loud about what this app will do. I find it easiest to start with actions: what the app will need to do. In this case: User creates a medicine with dosage information. User updates a medicine with new information. User records a dose, and the app updates the next dose. User removes a dose that was incorrectly entered. User archives a medicine they are no longer taking. User removes a medicine they no longer need data for. User un-archives a medicine they are taking again. That's enough for us to define our domain model , the core of the application logic. And we can already see some nouns and verbs that will guide us to our definitions: Entities (things that are stored and acted on) User Medicine Dose Commands (actions that are taken) Create Medicine Update Medicine Archive Medicine Restore Medicine (un-archive) Record Dose Delete Dose Events (results of actions) Medicine Created Medicine Updated Medicine Archived Medicine Restored Dose Added Dose Deleted That looks good to me! Step 1: Entities An Entity in Cavatappi is an object with an id , specifically a UUID from ramsey/uuid . It can be randomly generated or deterministically generated, but it has an ID. Our User entity is going to look pretty bare for now, as we only need the ID: use Cavatappi\\Foundation\\DomainEvent\\Entity; use Cavatappi\\Foundation\\Value; use Cavatappi\\Foundation\\Value\\ValueKit; use Ramsey\\Uuid\\UuidInterface; readonly class User implements Value, Entity { use ValueKit; public function __construct(public UuidInterface $id) {} } But this gives us a chance to talk about Value . In Cavatappi, every class is either a Value or a Service. Values store information, and Services encapsulate logic. It's how I stick to the single-responsibility principle . Value objects should be read-only, but this isn't enforced at the code level. (I tried; it breaks down too easily.) That's why instead of a superclass, we have an interface and a trait defining three methods: with - Creates a clone of the object with the given property changes. equals - Tests the object for equality with the given object, accounting for inconsistencies in properties. (For example: if a property is Stringable , it compares the string values instead of the objects themselves.) static reflect - Pulls information from annotations and PHP's type system into a standard format that can be modified. Most Value classes will only need to use ValueKit to get all this for free. Our Medicine entity will have a little more data: readonly class Medicine implements Value, Entity, Validated { use ValueKit; public UuidInterface $id; public function __construct( public string $name, public UuidInterface $userId, ?UuidInterface $id = null, public ?int $hourlyInterval = null, public ?int $dailyLimit = null, public bool $alert = false, public bool $archived = false, ) { $this->id = $id ?? UuidFactory::random(); $this->validate(); } public function validate(): void { if (isset($this->hourlyInterval) && $this->hourlyInterval <= 0) { throw new InvalidValueProperties('Hourly interval must be null or positive.', field: 'hourlyInterval'); } if (isset($this->dailyLimit) && $this->dailyLimit <= 0) { throw new InvalidValueProperties('Hourly interval must be null or positive.', field: 'dailyLimit'); } } } Here we're storing a name, the two pieces of timing information, and a couple of flags for application functions. We're also introducing the Validated interface. Since some scenarios (like serialization or cloning) bypass the constructor, this breaks validation out into a separate function, validate , that can be called outside of the constructor. We should still call it within the constructor! We're also adding a default ID. If one isn't provided (a.k.a. this is a new Medicine), the constructor will create one using UuidFactory , a static class for working with UUIDs inside a Value object. We'll round it out with Dose which is almost as simple as User: readonly class Dose implements Value, Entity { use ValueKit; public function __construct( public UuidInterface $id, public UuidInterface $medicineId, public DateTimeInterface $timestamp, ) { } } Step 2: Commands + Events Command and Event objects represent input and output to the domain model. Just like a function has parameters and a return value, a domain model takes command objects and dispatches events with the results. It helps disconnect our core logic from how our application is built: whether we use a PHP-based frontend or an API, our domain model will get the same input. (Plus, it helps define how to test the app, which we are going to do.) For the sake of brevity, we'll just look at a couple of command/event pairs. First, adding a Medicine: use Cavatappi\\Foundation\\Command\\Authenticated; use Cavatappi\\Foundation\\Command\\Command; use Cavatappi\\Foundation\\Value\\ValueKit; use oddEvan\\PillTimer\\Entities\\Medicine; use Ramsey\\Uuid\\UuidInterface; class AddMedicine implements Command, Authenticated { use ValueKit; public function __construct( public readonly Medicine $medicine, public readonly UuidInterface $userId, ) { } } The class itself is pretty sparse. But doing this allows us to use the validation code we already put in the Medicine entity class. The AddMedicine command basically says \"add this Medicine.\" The Authenticated interface requires a userId UUID property. It is assumed that the value of that property is a user that has been authenticated : that is, their identity has been verified and they are who they say they are, at least as far as our app is concerned. This authenticated user is the one performing the action, and it's whose authorization we'll check later. So why not just use $medicine->userId ? Good question! In this particular case, I'm making it a separate property to account for potential cases where a user is adding a Medicine for someone else. Maybe it's an import process, or an administrator making a change. Maybe there's a use-case later on for a family plan? Either way, it feels safer to have it be a separate property for now. The corresponding Event looks similar: use Cavatappi\\Foundation\\DomainEvent\\DomainEvent; use Cavatappi\\Foundation\\Factories\\UuidFactory; use DateTimeImmutable; use DateTimeInterface; use oddEvan\\PillTimer\\Entities\\Medicine; use Ramsey\\Uuid\\UuidInterface; class MedicineAdded implements DomainEvent { public readonly UuidInterface $id; public readonly DateTimeInterface $timestamp; public function __construct( public readonly Medicine $medicine, public readonly UuidInterface $userId, ?UuidInterface $id = null, ?DateTimeInterface $timestamp = null, public readonly ?UuidInterface $processId = null, ) { $this->timestamp = $timestamp ?? new DateTimeImmutable(); $this->id = $id ?? UuidFactory::date($this->timestamp); } public string $type { get => self::class; } public UuidInterface $entityId { get => $this->medicine->id; } public UuidInterface $aggregateId { get => $this->medicine->id; } } This has some added data, mostly to satisfy the DomainEvent interface. There's a lot here, mostly to facilitate indexing a stream of events: entityId is the ID for the entity being affected by this event, in this case the Medicine. aggregateId is the ID for a broader entity or group that this entity is part of. In this case, it's still the Medicine. processId is a way to denote events that are linked by a process, such as an import or remote system call. We're also using the UuidFactory::date function to create a version 7 UUID since events are created and stored in sequential order. To provide a little more context, here's a Command and Event for adding a Dose: readonly class AddDose implements Command, Authenticated { use ValueKit; public function __construct( public Dose $dose, public UuidInterface $userId, ) { } } class DoseAdded implements DomainEvent { public readonly UuidInterface $id; public readonly DateTimeInterface $timestamp; public function __construct( public readonly Dose $dose, public readonly UuidInterface $userId, ?UuidInterface $id = null, ?DateTimeInterface $timestamp = null, public readonly ?UuidInterface $processId = null, ) { $this->timestamp = $timestamp ?? new DateTimeImmutable(); $this->id = $id ?? UuidFactory::date($this->timestamp); } public string $type { get => self::class; } public UuidInterface $entityId { get => $this->dose->id; } public UuidInterface $aggregateId { get => $this->dose->medicineId; } } They're very simliar to the Medicine command and event. The most notable difference is while the entityId is the Dose ID, the aggregateId is still the Medicine ID since that's the \"group\" the Dose belongs to. Wrapup So wait, if the command and event are so similar, why not just combine them? Especially if the command is already authenticated? A big part of it is intent. A Command represents something that should happen, while an Event is something that has happened. In between the two is the domain model code, including authorization. While we know who is making the request, it is up to the domain model to determine if they can. Not every Command will result in an Event. As for how similar these Commands and Events are and how they look like copypasta, the very thing this framework wants to avoid? Well, that's being worked on. Hopefully, as we get closer to version 1, this walkthrough will look a little different.","title":"Values"},{"location":"walkthrough/02-values/#_1","text":"Let's set up some initial Value objects to represent the data we need.","title":""},{"location":"walkthrough/02-values/#step-0-figure-out-what-we-need","text":"A little bit of planning goes a long way. So let me think out loud about what this app will do. I find it easiest to start with actions: what the app will need to do. In this case: User creates a medicine with dosage information. User updates a medicine with new information. User records a dose, and the app updates the next dose. User removes a dose that was incorrectly entered. User archives a medicine they are no longer taking. User removes a medicine they no longer need data for. User un-archives a medicine they are taking again. That's enough for us to define our domain model , the core of the application logic. And we can already see some nouns and verbs that will guide us to our definitions: Entities (things that are stored and acted on) User Medicine Dose Commands (actions that are taken) Create Medicine Update Medicine Archive Medicine Restore Medicine (un-archive) Record Dose Delete Dose Events (results of actions) Medicine Created Medicine Updated Medicine Archived Medicine Restored Dose Added Dose Deleted That looks good to me!","title":"Step 0: Figure out what we need"},{"location":"walkthrough/02-values/#step-1-entities","text":"An Entity in Cavatappi is an object with an id , specifically a UUID from ramsey/uuid . It can be randomly generated or deterministically generated, but it has an ID. Our User entity is going to look pretty bare for now, as we only need the ID: use Cavatappi\\Foundation\\DomainEvent\\Entity; use Cavatappi\\Foundation\\Value; use Cavatappi\\Foundation\\Value\\ValueKit; use Ramsey\\Uuid\\UuidInterface; readonly class User implements Value, Entity { use ValueKit; public function __construct(public UuidInterface $id) {} } But this gives us a chance to talk about Value . In Cavatappi, every class is either a Value or a Service. Values store information, and Services encapsulate logic. It's how I stick to the single-responsibility principle . Value objects should be read-only, but this isn't enforced at the code level. (I tried; it breaks down too easily.) That's why instead of a superclass, we have an interface and a trait defining three methods: with - Creates a clone of the object with the given property changes. equals - Tests the object for equality with the given object, accounting for inconsistencies in properties. (For example: if a property is Stringable , it compares the string values instead of the objects themselves.) static reflect - Pulls information from annotations and PHP's type system into a standard format that can be modified. Most Value classes will only need to use ValueKit to get all this for free. Our Medicine entity will have a little more data: readonly class Medicine implements Value, Entity, Validated { use ValueKit; public UuidInterface $id; public function __construct( public string $name, public UuidInterface $userId, ?UuidInterface $id = null, public ?int $hourlyInterval = null, public ?int $dailyLimit = null, public bool $alert = false, public bool $archived = false, ) { $this->id = $id ?? UuidFactory::random(); $this->validate(); } public function validate(): void { if (isset($this->hourlyInterval) && $this->hourlyInterval <= 0) { throw new InvalidValueProperties('Hourly interval must be null or positive.', field: 'hourlyInterval'); } if (isset($this->dailyLimit) && $this->dailyLimit <= 0) { throw new InvalidValueProperties('Hourly interval must be null or positive.', field: 'dailyLimit'); } } } Here we're storing a name, the two pieces of timing information, and a couple of flags for application functions. We're also introducing the Validated interface. Since some scenarios (like serialization or cloning) bypass the constructor, this breaks validation out into a separate function, validate , that can be called outside of the constructor. We should still call it within the constructor! We're also adding a default ID. If one isn't provided (a.k.a. this is a new Medicine), the constructor will create one using UuidFactory , a static class for working with UUIDs inside a Value object. We'll round it out with Dose which is almost as simple as User: readonly class Dose implements Value, Entity { use ValueKit; public function __construct( public UuidInterface $id, public UuidInterface $medicineId, public DateTimeInterface $timestamp, ) { } }","title":"Step 1: Entities"},{"location":"walkthrough/02-values/#step-2-commands-events","text":"Command and Event objects represent input and output to the domain model. Just like a function has parameters and a return value, a domain model takes command objects and dispatches events with the results. It helps disconnect our core logic from how our application is built: whether we use a PHP-based frontend or an API, our domain model will get the same input. (Plus, it helps define how to test the app, which we are going to do.) For the sake of brevity, we'll just look at a couple of command/event pairs. First, adding a Medicine: use Cavatappi\\Foundation\\Command\\Authenticated; use Cavatappi\\Foundation\\Command\\Command; use Cavatappi\\Foundation\\Value\\ValueKit; use oddEvan\\PillTimer\\Entities\\Medicine; use Ramsey\\Uuid\\UuidInterface; class AddMedicine implements Command, Authenticated { use ValueKit; public function __construct( public readonly Medicine $medicine, public readonly UuidInterface $userId, ) { } } The class itself is pretty sparse. But doing this allows us to use the validation code we already put in the Medicine entity class. The AddMedicine command basically says \"add this Medicine.\" The Authenticated interface requires a userId UUID property. It is assumed that the value of that property is a user that has been authenticated : that is, their identity has been verified and they are who they say they are, at least as far as our app is concerned. This authenticated user is the one performing the action, and it's whose authorization we'll check later. So why not just use $medicine->userId ? Good question! In this particular case, I'm making it a separate property to account for potential cases where a user is adding a Medicine for someone else. Maybe it's an import process, or an administrator making a change. Maybe there's a use-case later on for a family plan? Either way, it feels safer to have it be a separate property for now. The corresponding Event looks similar: use Cavatappi\\Foundation\\DomainEvent\\DomainEvent; use Cavatappi\\Foundation\\Factories\\UuidFactory; use DateTimeImmutable; use DateTimeInterface; use oddEvan\\PillTimer\\Entities\\Medicine; use Ramsey\\Uuid\\UuidInterface; class MedicineAdded implements DomainEvent { public readonly UuidInterface $id; public readonly DateTimeInterface $timestamp; public function __construct( public readonly Medicine $medicine, public readonly UuidInterface $userId, ?UuidInterface $id = null, ?DateTimeInterface $timestamp = null, public readonly ?UuidInterface $processId = null, ) { $this->timestamp = $timestamp ?? new DateTimeImmutable(); $this->id = $id ?? UuidFactory::date($this->timestamp); } public string $type { get => self::class; } public UuidInterface $entityId { get => $this->medicine->id; } public UuidInterface $aggregateId { get => $this->medicine->id; } } This has some added data, mostly to satisfy the DomainEvent interface. There's a lot here, mostly to facilitate indexing a stream of events: entityId is the ID for the entity being affected by this event, in this case the Medicine. aggregateId is the ID for a broader entity or group that this entity is part of. In this case, it's still the Medicine. processId is a way to denote events that are linked by a process, such as an import or remote system call. We're also using the UuidFactory::date function to create a version 7 UUID since events are created and stored in sequential order. To provide a little more context, here's a Command and Event for adding a Dose: readonly class AddDose implements Command, Authenticated { use ValueKit; public function __construct( public Dose $dose, public UuidInterface $userId, ) { } } class DoseAdded implements DomainEvent { public readonly UuidInterface $id; public readonly DateTimeInterface $timestamp; public function __construct( public readonly Dose $dose, public readonly UuidInterface $userId, ?UuidInterface $id = null, ?DateTimeInterface $timestamp = null, public readonly ?UuidInterface $processId = null, ) { $this->timestamp = $timestamp ?? new DateTimeImmutable(); $this->id = $id ?? UuidFactory::date($this->timestamp); } public string $type { get => self::class; } public UuidInterface $entityId { get => $this->dose->id; } public UuidInterface $aggregateId { get => $this->dose->medicineId; } } They're very simliar to the Medicine command and event. The most notable difference is while the entityId is the Dose ID, the aggregateId is still the Medicine ID since that's the \"group\" the Dose belongs to.","title":"Step 2: Commands + Events"},{"location":"walkthrough/02-values/#wrapup","text":"So wait, if the command and event are so similar, why not just combine them? Especially if the command is already authenticated? A big part of it is intent. A Command represents something that should happen, while an Event is something that has happened. In between the two is the domain model code, including authorization. While we know who is making the request, it is up to the domain model to determine if they can. Not every Command will result in an Event. As for how similar these Commands and Events are and how they look like copypasta, the very thing this framework wants to avoid? Well, that's being worked on. Hopefully, as we get closer to version 1, this walkthrough will look a little different.","title":"Wrapup"}]}