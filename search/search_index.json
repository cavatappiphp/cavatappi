{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Cavatappi PHP Framework Documentation This is the documentation for the Cavatappi framework. For a general overview of the framework philosophy (the \"why\"), start with About the Framework . For a look at where things are going, see the Roadmap . For detailed info on how to use the framework, browse Packages . For a good time, call Strong Bad .","title":"Cavatappi PHP Framework Documentation"},{"location":"#cavatappi-php-framework-documentation","text":"This is the documentation for the Cavatappi framework. For a general overview of the framework philosophy (the \"why\"), start with About the Framework . For a look at where things are going, see the Roadmap . For detailed info on how to use the framework, browse Packages . For a good time, call Strong Bad .","title":"Cavatappi PHP Framework Documentation"},{"location":"about/","text":"About Cavatappi I'll assume you already know the benefits of using a framework, but if you don't, the TL;DR is less boilerplate code for you to write and maintain, which leaves you more time to focus on your app. So when I tell you that instead of using any of the existing frameworks I decided to build my own, you should have at least one question: Why? But Why? The short answer is because I wanted to. To elaborate, I was working on a big project with a small name and wanted to truly understand what my code was doing. I wanted to put the object-oriented lessons I was finally understanding into practice. I wanted something testable, portable, and lightweight. And I had just enough of a grasp of the modern PHP ecosystem to feel like I could do it, but not enough experience to tell me not to. This does beg another question: why should you use Cavatappi? Let me be a little blunt: you shouldn't. Don't use this Cavatappi, while born out of an existing project, does not currently have a production app to showcase it. It's ready for me to show the world, but it's not in a place where I'm comfortable using it for real production work. That being said, if the ideas on this site resonate with you and you want to help out, check out the GitHub repo and see what you can contribute. Why the name, though? I don't like cut-and-paste code. Lots of boilerplate tells me there's a chance for an abstraction, or at least a way to provide some sane defaults. So that's why the framework is named after a pasta: because I don't like copypasta. I chose this specific pasta because... The domain name was available, and It kinda looks like a snake. Thus, Cavatappi. Axioms Yes, it's reductive, but it helps get the ideas across. So here's some guiding principles for the Cavatappi framework: Defaults, not Dogma : Build features and abstractions so that simple apps can be written with minimal code, but deviations from the norm don't require re-implementing the entire feature. Try to maximize what can be done before a developer needs to abandon the framework's abstraction entirely. Signals, not Magic : Use explicit signals like PHP's type system and annotations to opt into behavior. Don't change the framework's behavior because a file is in a particular folder or a parameter has a particular name. The Basic Idea The basis for Cavatappi is that every class is either a Value or a Service : Value objects are (generally) immutable and used to store structured data. They should have no dependencies and be internally consistent. Value objects house state , not logic. Service objects are (generally) stateless and used to perform operations. They are given the dependencies they need at construction in order to work with structured data. Service objects house logic , not state. The Details Cavatappi takes this overall philosophy and uses it to help you build a well-organized app. Some other concepts make their way in, like: Registries : Find all classes that implement a particular interface and store information about them in a central location. This is currently the way to introduce extendability into applications. Commands and Events : Build a Domain Model that takes Command objects as input and dispatches Event objects with the result. Reflection : Use PHP's type system and annotations to build a meta-picture of classes that can be used to inform application behavior. Domain-driven Design : Isolate core application logic from general application concerns. Downstream Libraries Despite the foolishness of this endeavor, Cavatappi does build off several existing PHP libraries: Tukio and Serde by Larry Garfield ramsey/uuid by Ben Ramsey Construct Finder by The League of Extraordinary Packages nyholm/psr7 by Tobias Nyholm and Martijn van der Ven PHPUnit by Sebastian Bergmann","title":"About"},{"location":"about/#about-cavatappi","text":"I'll assume you already know the benefits of using a framework, but if you don't, the TL;DR is less boilerplate code for you to write and maintain, which leaves you more time to focus on your app. So when I tell you that instead of using any of the existing frameworks I decided to build my own, you should have at least one question:","title":"About Cavatappi"},{"location":"about/#why","text":"But Why? The short answer is because I wanted to. To elaborate, I was working on a big project with a small name and wanted to truly understand what my code was doing. I wanted to put the object-oriented lessons I was finally understanding into practice. I wanted something testable, portable, and lightweight. And I had just enough of a grasp of the modern PHP ecosystem to feel like I could do it, but not enough experience to tell me not to. This does beg another question: why should you use Cavatappi? Let me be a little blunt: you shouldn't.","title":"Why?"},{"location":"about/#dont-use-this","text":"Cavatappi, while born out of an existing project, does not currently have a production app to showcase it. It's ready for me to show the world, but it's not in a place where I'm comfortable using it for real production work. That being said, if the ideas on this site resonate with you and you want to help out, check out the GitHub repo and see what you can contribute.","title":"Don't use this"},{"location":"about/#why-the-name-though","text":"I don't like cut-and-paste code. Lots of boilerplate tells me there's a chance for an abstraction, or at least a way to provide some sane defaults. So that's why the framework is named after a pasta: because I don't like copypasta. I chose this specific pasta because... The domain name was available, and It kinda looks like a snake. Thus, Cavatappi.","title":"Why the name, though?"},{"location":"about/#axioms","text":"Yes, it's reductive, but it helps get the ideas across. So here's some guiding principles for the Cavatappi framework: Defaults, not Dogma : Build features and abstractions so that simple apps can be written with minimal code, but deviations from the norm don't require re-implementing the entire feature. Try to maximize what can be done before a developer needs to abandon the framework's abstraction entirely. Signals, not Magic : Use explicit signals like PHP's type system and annotations to opt into behavior. Don't change the framework's behavior because a file is in a particular folder or a parameter has a particular name.","title":"Axioms"},{"location":"about/#the-basic-idea","text":"The basis for Cavatappi is that every class is either a Value or a Service : Value objects are (generally) immutable and used to store structured data. They should have no dependencies and be internally consistent. Value objects house state , not logic. Service objects are (generally) stateless and used to perform operations. They are given the dependencies they need at construction in order to work with structured data. Service objects house logic , not state.","title":"The Basic Idea"},{"location":"about/#the-details","text":"Cavatappi takes this overall philosophy and uses it to help you build a well-organized app. Some other concepts make their way in, like: Registries : Find all classes that implement a particular interface and store information about them in a central location. This is currently the way to introduce extendability into applications. Commands and Events : Build a Domain Model that takes Command objects as input and dispatches Event objects with the result. Reflection : Use PHP's type system and annotations to build a meta-picture of classes that can be used to inform application behavior. Domain-driven Design : Isolate core application logic from general application concerns.","title":"The Details"},{"location":"about/#downstream-libraries","text":"Despite the foolishness of this endeavor, Cavatappi does build off several existing PHP libraries: Tukio and Serde by Larry Garfield ramsey/uuid by Ben Ramsey Construct Finder by The League of Extraordinary Packages nyholm/psr7 by Tobias Nyholm and Martijn van der Ven PHPUnit by Sebastian Bergmann","title":"Downstream Libraries"},{"location":"roadmap/","text":"Roadmap Everything is subject to change. Even this. Especially this. Current This is what's in the framework now Dependency Injection Using a stupidly simple container . Register Services automatically. Set up concrete implementations of interfaces and abstract classes. Registries Surfacing a class to the system is as simple as implements Interface . Register different adapters, add services to the dependency injection container, or other uses. Commands and Events Using a custom-built Command Bus and Tukio for event dispatching. Define a domain model with Commands as input and Events as output. Auto-register Command handlers and Event listeners. Sets up event sourcing for data persistence. Version 1 This is what I would consider the needed feature set before calling the framework ready for general use. API Set up a registry and configuration for an Endpoint class so that endpoints can be auto-registered. Use reflection tools to generate an OpenAPI (or similar) spec. Integrate with (or provide adapter to) something like Slim to handle routing. Markdown Registry system for Markdown customizations. Data Persistence Make it as easy to do event sourcing as most frameworks make CRUD . Registry for database tables. Integrate with Doctrine DBAL . Authentication Integrate with some library (what's the PHP equivalent to Omniauth ?) Create extendable User entity Some kind of OAuth or JWT scheme to secure APIs Make this effortless. Like, really effortless. Like works-out-of-the-box effortless. Further Enhancements The lofty ideas of things beyond version 1. UI Framework Build encapsulated UI components in PHP Use other design systems as a base and layer customizations on top Use reflection to make a form builder. Or just make a form builder. Seriously, can I have a form builder? Static Site Generation Have a way to generate HTML pages and save them to disk. Useful for making landing pages or outputting a single-page app Build System Generate hard-coded configurations and setups for Registries and other high-use classes. Optimize the system when it's in a stable place (staging/production) without compromising development speed. Allow other systems to hook in for generating documentation, web pages, etc. Smolblog That is why this whole thing started.","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"Everything is subject to change. Even this. Especially this.","title":"Roadmap"},{"location":"roadmap/#current","text":"This is what's in the framework now","title":"Current"},{"location":"roadmap/#dependency-injection","text":"Using a stupidly simple container . Register Services automatically. Set up concrete implementations of interfaces and abstract classes.","title":"Dependency Injection"},{"location":"roadmap/#registries","text":"Surfacing a class to the system is as simple as implements Interface . Register different adapters, add services to the dependency injection container, or other uses.","title":"Registries"},{"location":"roadmap/#commands-and-events","text":"Using a custom-built Command Bus and Tukio for event dispatching. Define a domain model with Commands as input and Events as output. Auto-register Command handlers and Event listeners. Sets up event sourcing for data persistence.","title":"Commands and Events"},{"location":"roadmap/#version-1","text":"This is what I would consider the needed feature set before calling the framework ready for general use.","title":"Version 1"},{"location":"roadmap/#api","text":"Set up a registry and configuration for an Endpoint class so that endpoints can be auto-registered. Use reflection tools to generate an OpenAPI (or similar) spec. Integrate with (or provide adapter to) something like Slim to handle routing.","title":"API"},{"location":"roadmap/#markdown","text":"Registry system for Markdown customizations.","title":"Markdown"},{"location":"roadmap/#data-persistence","text":"Make it as easy to do event sourcing as most frameworks make CRUD . Registry for database tables. Integrate with Doctrine DBAL .","title":"Data Persistence"},{"location":"roadmap/#authentication","text":"Integrate with some library (what's the PHP equivalent to Omniauth ?) Create extendable User entity Some kind of OAuth or JWT scheme to secure APIs Make this effortless. Like, really effortless. Like works-out-of-the-box effortless.","title":"Authentication"},{"location":"roadmap/#further-enhancements","text":"The lofty ideas of things beyond version 1.","title":"Further Enhancements"},{"location":"roadmap/#ui-framework","text":"Build encapsulated UI components in PHP Use other design systems as a base and layer customizations on top Use reflection to make a form builder. Or just make a form builder. Seriously, can I have a form builder?","title":"UI Framework"},{"location":"roadmap/#static-site-generation","text":"Have a way to generate HTML pages and save them to disk. Useful for making landing pages or outputting a single-page app","title":"Static Site Generation"},{"location":"roadmap/#build-system","text":"Generate hard-coded configurations and setups for Registries and other high-use classes. Optimize the system when it's in a stable place (staging/production) without compromising development speed. Allow other systems to hook in for generating documentation, web pages, etc.","title":"Build System"},{"location":"roadmap/#smolblog","text":"That is why this whole thing started.","title":"Smolblog"},{"location":"packages/","text":"Packages Foundation Everything you need to define and build a Domain Model. Infrastructure Application-level utilities and services. Testing Because you need to write tests. Yes, you. And you.","title":"Packages"},{"location":"packages/#packages","text":"Foundation Everything you need to define and build a Domain Model. Infrastructure Application-level utilities and services. Testing Because you need to write tests. Yes, you. And you.","title":"Packages"},{"location":"packages/foundation/","text":"Cavatappi Foundation Base-level interfaces and traits for defining a domain model. Installation composer require cavatappi/foundation","title":"Cavatappi Foundation"},{"location":"packages/foundation/#cavatappi-foundation","text":"Base-level interfaces and traits for defining a domain model.","title":"Cavatappi Foundation"},{"location":"packages/foundation/#installation","text":"composer require cavatappi/foundation","title":"Installation"},{"location":"packages/infrastructure/","text":"Cavatappi Foundation Application-level services. Installation composer require cavatappi/infrastructure","title":"Cavatappi Foundation"},{"location":"packages/infrastructure/#cavatappi-foundation","text":"Application-level services.","title":"Cavatappi Foundation"},{"location":"packages/infrastructure/#installation","text":"composer require cavatappi/infrastructure","title":"Installation"},{"location":"packages/testing/","text":"Cavatappi Test Utilities Make tests suck less. Because you need to write them. Yes, you. Installation composer require --dev cavatappi/testing","title":"Cavatappi Test Utilities"},{"location":"packages/testing/#cavatappi-test-utilities","text":"Make tests suck less. Because you need to write them. Yes, you.","title":"Cavatappi Test Utilities"},{"location":"packages/testing/#installation","text":"composer require --dev cavatappi/testing","title":"Installation"}]}