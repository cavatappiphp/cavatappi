{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Cavatappi PHP Framework Documentation This is the documentation for the Cavatappi framework. For a general overview of the framework philosophy (the \"why\"), start with About the Framework . For a tutorial on setting up your first app, head to the Tutorial . For detailed info on how to use the framework, browse Packages . For a good time, call Strong Bad .","title":"Cavatappi PHP Framework Documentation"},{"location":"#cavatappi-php-framework-documentation","text":"This is the documentation for the Cavatappi framework. For a general overview of the framework philosophy (the \"why\"), start with About the Framework . For a tutorial on setting up your first app, head to the Tutorial . For detailed info on how to use the framework, browse Packages . For a good time, call Strong Bad .","title":"Cavatappi PHP Framework Documentation"},{"location":"about/","text":"About Cavatappi I'll assume you already know the benefits of using a framework, but if you don't, the TL;DR is less boilerplate code for you to write and maintain, which leaves you more time to focus on your app. So when I tell you that instead of using any of the existing frameworks I decided to build my own, you should have at least one question: Why? But Why? The short answer is because I wanted to. To elaborate, I was working on a big project with a small name and wanted to truly understand what my code was doing. I wanted to put the object-oriented lessons I was finally understanding into practice. I wanted something testable, portable, and lightweight. And I had just enough of a grasp of the modern PHP ecosystem to feel like I could do it, but not enough experience to tell me not to. This does beg another question: why should you use Cavatappi? Let me be a little blunt: you shouldn't. Don't use this Cavatappi, while born out of an existing project, does not currently have a production app to showcase it. It's ready for me to show the world, but it's not in a place where I'm comfortable using it for real production work. That being said, if the ideas on this site resonate with you and you want to help out, check out the GitHub repo and see what you can contribute. Why the name, though? I don't like cut-and-paste code. Lots of boilerplate tells me there's a chance for an abstraction, or at least a way to provide some sane defaults. So that's why the framework is named after a pasta: because I don't like copypasta. I chose this specific pasta because... The domain name was available, and It kinda looks like a snake. Thus, Cavatappi. Axioms Yes, it's reductive, but it helps get the ideas across. So here's some guiding principles for the Cavatappi framework: Defaults, not Dogma : Build features and abstractions so that simple apps can be written with minimal code, but deviations from the norm don't require re-implementing the entire feature. Try to maximize what can be done before a developer needs to abandon the framework's abstraction entirely. Signals, not Magic : Use explicit signals like PHP's type system and annotations to opt into behavior. Don't change the framework's behavior because a file is in a particular folder or a parameter has a particular name. The Basic Idea The basis for Cavatappi is that every class is either a Value or a Service : Value objects are (generally) immutable and used to store structured data. They should have no dependencies and be internally consistent. Value objects house state , not logic. Service objects are (generally) stateless and used to perform operations. They are given the dependencies they need at construction in order to work with structured data. Service objects house logic , not state. The Details Cavatappi takes this overall philosophy and uses it to help you build a well-organized app. Some other concepts make their way in, like: Registries : Find all classes that implement a particular interface and store information about them in a central location. This is currently the way to introduce extendability into applications. Commands and Events : Build a Domain Model that takes Command objects as input and dispatches Event objects with the result. Reflection : Use PHP's type system and annotations to build a meta-picture of classes that can be used to inform application behavior. Domain-driven Design : Isolate core application logic from general application concerns.","title":"About"},{"location":"about/#about-cavatappi","text":"I'll assume you already know the benefits of using a framework, but if you don't, the TL;DR is less boilerplate code for you to write and maintain, which leaves you more time to focus on your app. So when I tell you that instead of using any of the existing frameworks I decided to build my own, you should have at least one question:","title":"About Cavatappi"},{"location":"about/#why","text":"But Why? The short answer is because I wanted to. To elaborate, I was working on a big project with a small name and wanted to truly understand what my code was doing. I wanted to put the object-oriented lessons I was finally understanding into practice. I wanted something testable, portable, and lightweight. And I had just enough of a grasp of the modern PHP ecosystem to feel like I could do it, but not enough experience to tell me not to. This does beg another question: why should you use Cavatappi? Let me be a little blunt: you shouldn't.","title":"Why?"},{"location":"about/#dont-use-this","text":"Cavatappi, while born out of an existing project, does not currently have a production app to showcase it. It's ready for me to show the world, but it's not in a place where I'm comfortable using it for real production work. That being said, if the ideas on this site resonate with you and you want to help out, check out the GitHub repo and see what you can contribute.","title":"Don't use this"},{"location":"about/#why-the-name-though","text":"I don't like cut-and-paste code. Lots of boilerplate tells me there's a chance for an abstraction, or at least a way to provide some sane defaults. So that's why the framework is named after a pasta: because I don't like copypasta. I chose this specific pasta because... The domain name was available, and It kinda looks like a snake. Thus, Cavatappi.","title":"Why the name, though?"},{"location":"about/#axioms","text":"Yes, it's reductive, but it helps get the ideas across. So here's some guiding principles for the Cavatappi framework: Defaults, not Dogma : Build features and abstractions so that simple apps can be written with minimal code, but deviations from the norm don't require re-implementing the entire feature. Try to maximize what can be done before a developer needs to abandon the framework's abstraction entirely. Signals, not Magic : Use explicit signals like PHP's type system and annotations to opt into behavior. Don't change the framework's behavior because a file is in a particular folder or a parameter has a particular name.","title":"Axioms"},{"location":"about/#the-basic-idea","text":"The basis for Cavatappi is that every class is either a Value or a Service : Value objects are (generally) immutable and used to store structured data. They should have no dependencies and be internally consistent. Value objects house state , not logic. Service objects are (generally) stateless and used to perform operations. They are given the dependencies they need at construction in order to work with structured data. Service objects house logic , not state.","title":"The Basic Idea"},{"location":"about/#the-details","text":"Cavatappi takes this overall philosophy and uses it to help you build a well-organized app. Some other concepts make their way in, like: Registries : Find all classes that implement a particular interface and store information about them in a central location. This is currently the way to introduce extendability into applications. Commands and Events : Build a Domain Model that takes Command objects as input and dispatches Event objects with the result. Reflection : Use PHP's type system and annotations to build a meta-picture of classes that can be used to inform application behavior. Domain-driven Design : Isolate core application logic from general application concerns.","title":"The Details"},{"location":"start/","text":"Getting Started Tutorial coming soon. Like, really soon.","title":"Tutorial"},{"location":"start/#getting-started","text":"Tutorial coming soon. Like, really soon.","title":"Getting Started"},{"location":"packages/","text":"Packages Foundation Everything you need to define and build a Domain Model. Infrastructure Application-level utilities and services. Testing Because you need to write tests. Yes, you. And you.","title":"Packages"},{"location":"packages/#packages","text":"Foundation Everything you need to define and build a Domain Model. Infrastructure Application-level utilities and services. Testing Because you need to write tests. Yes, you. And you.","title":"Packages"},{"location":"packages/foundation/","text":"Cavatappi Foundation Base-level interfaces and traits for defining a domain model. Installation composer require cavatappi/foundation","title":"Cavatappi Foundation"},{"location":"packages/foundation/#cavatappi-foundation","text":"Base-level interfaces and traits for defining a domain model.","title":"Cavatappi Foundation"},{"location":"packages/foundation/#installation","text":"composer require cavatappi/foundation","title":"Installation"},{"location":"packages/infrastructure/","text":"Cavatappi Foundation Application-level services. Installation composer require cavatappi/infrastructure","title":"Cavatappi Foundation"},{"location":"packages/infrastructure/#cavatappi-foundation","text":"Application-level services.","title":"Cavatappi Foundation"},{"location":"packages/infrastructure/#installation","text":"composer require cavatappi/infrastructure","title":"Installation"},{"location":"packages/testing/","text":"Cavatappi Test Utilities Make tests suck less. Because you need to write them. Yes, you. Installation composer require --dev cavatappi/testing","title":"Cavatappi Test Utilities"},{"location":"packages/testing/#cavatappi-test-utilities","text":"Make tests suck less. Because you need to write them. Yes, you.","title":"Cavatappi Test Utilities"},{"location":"packages/testing/#installation","text":"composer require --dev cavatappi/testing","title":"Installation"}]}